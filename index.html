<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gift Card Creator</title>
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- CCMETCON Font (if custom, will fallback to bold sans-serif) -->
  <style>
    @font-face {
      font-family: 'CCMETCON';
      src: local('CCMETCON'), url('CCMETCON.woff2') format('woff2'), url('CCMETCON.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
  </style>
  
  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- HEIC to JPEG converter for iPhone photos -->
  <script src="https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js"></script>
  
  <style>
    :root {
      /* Dreamy Boutique Brand Colors */
      --main-pink: #FED5D4;
      --main-red: #E4412D;
      --accent-aqua: #AEEEEE;
      --secondary-white: #F9F0F0;
      
      /* Derived Colors for UI */
      --pink-light: #FED5D4;
      --pink: #FED5D4;
      --pink-medium: #F9C5C4;
      --pink-dark: #E4412D;
      --red: #E4412D;
      --aqua: #AEEEEE;
      --white-soft: #F9F0F0;
      --gold: #E4412D;
      --gold-light: #FED5D4;
      --cream: #F9F0F0;
      --warm-brown: #E4412D;
      --text-dark: #4a3f44;
      --text-light: #7d6b70;
      --success: #10b981;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Quicksand', sans-serif;
      background: var(--secondary-white);
      color: var(--text-dark);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ========== LAYOUT ========== */
    .app-container {
      display: flex;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden; /* Prevent horizontal overflow */
    }

    /* ========== LEFT PANEL ========== */
    .left-panel {
      width: 340px;
      min-width: 340px;
      background: white;
      border-right: 1px solid var(--main-pink);
      display: flex;
      flex-direction: column;
      box-shadow: 4px 0 30px rgba(254, 213, 212, 0.2);
      flex-shrink: 0;
    }

    /* Ensure right panel fills remaining space */
    @media (min-width: 769px) {
      .right-panel {
        width: calc(100% - 340px);
      }
    }

    /* Hide mobile elements on desktop */
    .mobile-toggle-btn {
      display: none;
    }
    .mobile-panel-backdrop {
      display: none;
    }
    .mobile-save-btn {
      display: none;
    }

    /* ========== MOBILE LAYOUT ========== */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: row;
        min-height: 100vh;
        overflow: hidden;
        position: relative;
      }

      .left-panel {
        position: fixed;
        left: 0;
        top: 0;
        width: calc(85% - 10px);
        max-width: 330px;
        min-width: auto;
        height: 100vh;
        max-height: 100vh;
        border-right: none;
        box-shadow: 4px 0 30px rgba(0, 0, 0, 0.15);
        z-index: 900;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .left-panel.mobile-open {
        transform: translateX(0);
      }

      /* Panel is shown when mobile-open class is present */

      .mobile-panel-backdrop {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
        z-index: 899;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .mobile-panel-backdrop.visible {
        display: block;
        opacity: 1;
      }

      /* Show backdrop when editing */
      .mobile-panel-backdrop.editing {
        display: block;
        opacity: 1;
      }

      .mobile-toggle-btn {
        display: flex;
        position: fixed;
        left: 50%;
        bottom: 40px;
        transform: translateX(-50%);
        padding: 16px 32px;
        background: var(--main-red);
        border: none;
        border-radius: 2rem;
        color: white;
        font-family: 'Quicksand', sans-serif;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 1px;
        align-items: center;
        justify-content: center;
        gap: 6px;
        z-index: 901;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(228, 65, 45, 0.4);
        transition: all 0.3s ease;
        min-width: 200px;
        max-width: calc(100% - 40px);
      }

      .mobile-toggle-btn:active {
        transform: translateX(-50%) scale(0.95);
      }

      .mobile-toggle-btn:hover {
        box-shadow: 0 6px 25px rgba(228, 65, 45, 0.5);
      }

      /* Mobile save button on card preview */
      .mobile-save-btn {
        display: block;
        position: fixed;
        right: 12px;
        top: 12px;
        padding: 10px 20px;
        background: var(--main-red);
        border: none;
        border-radius: 2rem;
        color: white;
        font-family: 'Quicksand', sans-serif;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 1px;
        z-index: 800;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
      }

      .mobile-save-btn:active {
        transform: scale(0.95);
      }

      /* Mobile card dots indicator */
      .mobile-card-dots {
        display: flex;
        position: fixed;
        left: 50%;
        top: 16px;
        transform: translateX(-50%);
        gap: 10px;
        z-index: 900;
        align-items: center;
        justify-content: center;
        padding: 4px 12px;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .mobile-card-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: rgba(228, 65, 45, 0.3);
        transition: all 0.3s ease;
      }

      .mobile-card-dot.active {
        background: var(--main-red);
        width: 10px;
        height: 10px;
      }

      /* Mobile back button */
      .mobile-back-btn {
        display: flex;
        position: fixed;
        left: 12px;
        top: 12px;
        padding: 10px 16px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(228, 65, 45, 0.2);
        border-radius: 2rem;
        color: var(--main-red);
        font-family: 'Quicksand', sans-serif;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 1px;
        align-items: center;
        justify-content: center;
        gap: 6px;
        z-index: 901;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .mobile-back-btn:active {
        transform: scale(0.95);
      }

      .mobile-back-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      /* Mobile panel pull tab/arrow - always visible when editing */
      .mobile-panel-tab {
        display: flex;
        position: fixed;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 32px;
        height: 80px;
        background: var(--main-red);
        border-radius: 0 12px 12px 0;
        align-items: center;
        justify-content: center;
        z-index: 902;
        cursor: pointer;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
      }

      .mobile-panel-tab::before {
        content: '→';
        color: white;
        font-size: 20px;
        font-weight: bold;
        transition: transform 0.3s ease;
      }

      .mobile-panel-tab.panel-open::before {
        transform: rotate(180deg);
      }

      .mobile-panel-tab:active {
        transform: translateY(-50%) scale(0.95);
      }

      .panel-content {
        max-height: none;
        overflow-y: auto;
        padding-bottom: 100px;
      }

      .right-panel {
        width: 100%;
        min-height: 100vh;
        padding: 1.5rem;
        padding-top: 70px;
      }

      .right-panel-text {
        display: none; /* Hide decorative text on mobile */
      }

      .mobile-list-hint {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
        color: var(--text-dark);
        padding: 2rem;
        padding-bottom: 120px; /* Space for bottom button */
      }

      .mobile-list-hint .hint-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
      }

      .mobile-list-hint .headline {
        font-family: 'Quicksand', sans-serif;
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--main-red);
        margin-bottom: 1.5rem;
        line-height: 1.2;
        letter-spacing: 1px;
      }

      .mobile-list-hint .sub-headline {
        font-family: 'Quicksand', sans-serif;
        font-size: 1rem;
        color: var(--text-light);
        opacity: 0.8;
        max-width: 320px;
        line-height: 1.6;
        letter-spacing: 0.3px;
        margin-bottom: 2rem;
      }

      .mobile-list-hint p {
        font-family: 'Quicksand', sans-serif;
        font-size: 1rem;
        opacity: 0.7;
        max-width: 200px;
      }
    }

    /* Hide mobile hint on desktop */
    @media (min-width: 769px) {
      .mobile-list-hint {
        display: none;
      }
      .mobile-card-dots {
        display: none;
      }
      .mobile-back-btn {
        display: none;
      }
      .mobile-panel-tab {
        display: none;
      }
    }

    .panel-header {
      padding: 1.5rem;
      text-align: center;
      border-bottom: none;
      position: relative;
    }

    .panel-header h1 {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--main-red);
      letter-spacing: 1px;
      text-transform: uppercase;
      margin: 0;
    }

    .panel-header .subtitle {
      display: none;
    }

    .back-btn {
      position: absolute;
      top: 50%;
      left: 1rem;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 1.4rem;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.2s;
    }

    .back-btn:hover {
      opacity: 1;
      transform: translateY(-50%) translateX(-2px);
    }

    .start-fresh-btn {
      position: absolute;
      top: 50%;
      right: 1rem;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.9);
      border: 1px solid var(--accent-primary);
      color: var(--accent-primary);
      font-size: 0.75rem;
      padding: 0.4rem 0.8rem;
      border-radius: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .start-fresh-btn:hover {
      background: var(--accent-primary);
      color: white;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
    }

    .panel-footer {
      padding: 1.5rem;
      border-top: none;
      background: transparent;
      display: flex;
      justify-content: center;
    }

    /* ========== ATTRIBUTION FOOTER ========== */
    .attribution-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(254, 213, 212, 0.3);
      z-index: 100;
      font-family: 'Quicksand', sans-serif;
      font-size: 13px;
      color: var(--text-light);
    }

    .attribution-footer a {
      color: var(--main-red);
      text-decoration: none;
      font-weight: 500;
      transition: opacity 0.2s;
    }

    .attribution-footer a:hover {
      opacity: 0.8;
    }

    .attribution-footer .heart {
      color: var(--main-red);
      margin: 0 4px;
    }

    /* ========== SECTIONS ========== */
    .section {
      margin-bottom: 1.5rem;
    }

    .section-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: 0.8rem;
      font-weight: 500;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--text-light);
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--pink);
    }

    /* ========== DAY LIST ========== */
    .day-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .day-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      background: var(--secondary-white);
      border: 2px solid var(--main-red);
      border-radius: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      min-height: 70px;
    }

    .day-item:hover {
      border-color: var(--main-red);
      transform: scale(1.02);
    }

    .day-item.completed {
      background: var(--secondary-white);
      border-color: var(--main-red);
      opacity: 0.5;
      pointer-events: auto;
    }

    .day-item.completed:hover {
      transform: none;
      border-color: var(--main-red);
    }

    .day-item .day-content {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex: 1;
    }

    .day-item .day-label {
      font-family: 'Quicksand', sans-serif;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--main-red);
      text-transform: uppercase;
      margin: 0;
      padding: 0;
    }

    .day-item .status {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      color: var(--main-red);
      margin-top: 0.25rem;
      text-decoration: underline;
      text-transform: uppercase;
    }

    .day-item .arrow {
      width: 0;
      height: 0;
      border-left: 8px solid var(--main-red);
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      margin-left: 1rem;
    }

    .day-item .emoji {
      display: none;
    }

    /* ========== SCHEDULE BOX ========== */
    .schedule-box {
      background: var(--secondary-white);
      border: 1px solid var(--accent-aqua);
      border-radius: 0.75rem;
      padding: 1rem;
    }

    .schedule-box label {
      display: block;
      font-size: 0.7rem;
      color: var(--text-light);
      margin-bottom: 0.4rem;
      font-weight: 500;
    }

    .schedule-box input[type="date"] {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border: 1px solid var(--pink);
      border-radius: 0.4rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.85rem;
      color: var(--text-dark);
      background: white;
    }

    .schedule-box input[type="date"]:focus {
      outline: none;
      border-color: var(--accent-aqua);
    }

    .schedule-info {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px dashed var(--pink);
      font-size: 0.7rem;
      color: var(--text-light);
    }

    .schedule-info .day-unlock {
      display: flex;
      justify-content: space-between;
      padding: 0.25rem 0;
    }

    /* ========== EDIT FORM ========== */
    .edit-section {
      margin-bottom: 1.5rem;
    }

    .edit-section h3 {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: var(--main-red);
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--main-red);
    }

    .template-grid {
      display: flex;
      gap: 0.75rem;
      justify-content: space-between;
    }

    /* Scrollable image frame grid - shows 4, scrolls for rest */
    .template-grid.scrollable {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      max-height: 140px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .template-grid.scrollable::-webkit-scrollbar {
      width: 4px;
    }
    .template-grid.scrollable::-webkit-scrollbar-track {
      background: var(--pink-light);
      border-radius: 2px;
    }
    .template-grid.scrollable::-webkit-scrollbar-thumb {
      background: var(--main-red);
      border-radius: 2px;
    }

    .template-btn {
      flex: 1;
      aspect-ratio: 1;
      background: white;
      border: 2px solid var(--main-pink);
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      padding: 0;
    }

    .template-btn img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .template-btn::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(254, 213, 212, 0);
      transition: background 0.2s ease;
      pointer-events: none;
    }

    .template-btn:hover::after {
      background: rgba(254, 213, 212, 0.3);
    }

    .template-btn:hover {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .template-btn.active {
      border-color: var(--main-red);
      border-width: 3px;
      box-shadow: 0 4px 12px rgba(228, 65, 45, 0.2);
    }

    .template-btn .icon,
    .template-btn .label {
      display: none;
    }

    .input-group {
      margin-bottom: 0.6rem;
    }

    .input-group label {
      display: block;
      font-size: 0.65rem;
      color: var(--text-light);
      margin-bottom: 0.25rem;
      font-weight: 500;
    }

    .input-group input,
    .input-group textarea {
      width: 100%;
      padding: 0.6rem 0.75rem;
      background: white;
      border: 1px solid var(--pink);
      border-radius: 0.4rem;
      color: var(--text-dark);
      font-family: 'Quicksand', sans-serif;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .input-group textarea {
      min-height: 70px;
      resize: vertical;
    }

    .input-group input:focus,
    .input-group textarea:focus {
      outline: none;
      border-color: var(--main-red);
      box-shadow: 0 0 0 3px rgba(228, 65, 45, 0.1);
    }

    .photo-options {
      display: flex;
      gap: 0.75rem;
    }

    .photo-upload-area {
      flex: 1;
      background: white;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 0.6rem;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .photo-upload-area:hover {
      border-color: rgba(0, 0, 0, 0.2);
      background: rgba(0, 0, 0, 0.02);
    }

    .photo-upload-area {
      position: relative;
      cursor: pointer;
      overflow: hidden;
    }
    
    /* File input is hidden but still accessible */
    .photo-upload-area input[type="file"] {
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* Mobile: Ensure upload area is touchable */
    @media (max-width: 768px) {
      .photo-upload-area {
        min-height: 44px; /* Minimum touch target size */
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(228, 65, 45, 0.1);
      }
      .photo-upload-area:active {
        background: rgba(0, 0, 0, 0.05);
        transform: scale(0.98);
      }
    }
    .photo-upload-area .upload-text { 
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      display: block;
    }

    .photo-camera-area {
      flex: 1;
      background: white;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 0.6rem;
      padding: 1rem;
      text-align: center;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23E4412D' stroke-width='2'%3E%3Cpath d='M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z'/%3E%3Ccircle cx='12' cy='13' r='4'/%3E%3C/svg%3E") 12 12, auto;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .photo-camera-area:hover {
      border-color: var(--main-red);
      background: rgba(228, 65, 45, 0.05);
    }

    .photo-camera-area input { display: none; }
    .photo-camera-area .camera-text { 
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      display: block;
    }

    .photo-preview-box {
      margin-top: 0.6rem;
      border-radius: 0.4rem;
      overflow: hidden;
      position: relative;
      border: 1px solid var(--pink);
    }

    .photo-preview-box img {
      width: 100%;
      height: 100px;
      object-fit: cover;
    }

    .photo-preview-box .remove-btn {
      position: absolute;
      top: 0.4rem;
      right: 0.4rem;
      background: rgba(220, 38, 38, 0.9);
      color: white;
      border: none;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr); /* 5 per row on laptop */
      gap: 0.5rem;
    }

    /* Tablet view: 4 per row */
    @media (max-width: 1024px) {
      .emoji-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* Mobile/iPhone view: 2 per row */
    @media (max-width: 480px) {
      .emoji-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
      }
    }

    .emoji-btn {
      aspect-ratio: 1;
      background: white;
      border: 2px solid var(--pink);
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      padding: 0.4rem;
      overflow: hidden;
      min-height: 50px; /* Bigger minimum size */
    }

    .emoji-btn:hover {
      border-color: var(--main-red);
      transform: scale(1.08);
      background: var(--main-pink);
    }

    /* ========== BUTTONS ========== */
    .btn-primary {
      width: 100%;
      padding: 0.85rem;
      background: var(--main-red);
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(228, 65, 45, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(228, 65, 45, 0.4);
    }

    .btn-gold {
      width: auto;
      min-width: 280px;
      padding: 1rem 2rem;
      background: var(--main-red);
      border: none;
      border-radius: 1rem;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(228, 65, 45, 0.3);
    }

    .btn-gold:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(228, 65, 45, 0.4);
    }

    /* ========== RIGHT PANEL ========== */
    .right-panel {
      flex: 1;
      flex-grow: 1;
      min-width: 0; /* Allows flex item to shrink below content size */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
      overflow-x: hidden; /* Prevent horizontal overflow */
      overflow-y: auto; /* Allow vertical scrolling if needed */
    }

    /* Responsive: Mobile */
    @media (max-width: 768px) {
      .right-panel {
        min-width: 320px;
        padding: 20px;
        width: 100%;
      }
    }

    /* Very small screens */
    @media (max-width: 480px) {
      .right-panel {
        padding: 15px;
      }
    }

    .right-panel-text {
      position: absolute;
      font-family: 'CCMETCON', 'Quicksand', sans-serif;
      font-weight: 700;
      color: var(--main-red);
      pointer-events: none;
      z-index: 1;
      max-width: 600px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }

    .right-panel-text.top-right {
      top: 2rem;
      right: 2rem;
      text-align: right;
      font-size: 60px;
      line-height: 1.2;
      white-space: normal; /* Allow wrapping */
      transform-origin: top right;
      margin-left: auto;
    }

    .right-panel-text.bottom-left {
      bottom: 2rem;
      left: 2rem;
      text-align: left;
      font-size: 90px;
      line-height: 1.2;
      white-space: normal; /* Allow wrapping */
      transform-origin: bottom left;
      margin-right: auto;
    }

    /* Responsive text sizing */
    @media (max-width: 1024px) {
      .right-panel-text.top-right {
        font-size: 48px;
        max-width: 500px;
      }
      .right-panel-text.bottom-left {
        font-size: 72px;
        max-width: 500px;
      }
    }

    @media (max-width: 768px) {
      .right-panel-text.top-right {
        font-size: 36px;
        max-width: calc(100% - 40px);
        right: 20px;
        top: 20px;
      }
      .right-panel-text.bottom-left {
        font-size: 54px;
        max-width: calc(100% - 40px);
        left: 20px;
        bottom: 20px;
      }
    }

    @media (max-width: 480px) {
      .right-panel-text.top-right {
        font-size: 28px;
      }
      .right-panel-text.bottom-left {
        font-size: 42px;
      }
    }

    /* ========== CARD PREVIEW ========== */
    .card-preview {
      width: 320px;
      height: 560px;
      background: var(--main-pink);
      border-radius: 1rem;
      box-shadow: 0 25px 70px rgba(0, 0, 0, 0.15);
      position: relative;
      overflow: hidden;
    }

    @media (max-width: 768px) {
      .card-preview {
        width: 280px;
        height: 490px;
      }
    }

    @media (max-width: 480px) {
      .card-preview {
        width: 260px;
        height: 455px;
      }
    }

    .card-preview.stars-pattern::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .card-preview.clovers-pattern::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .card-preview.hearts-pattern::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Layer 2: Image Frame (below photo) */
    .card-image-frame {
      position: absolute;
      inset: 10px; /* 10px smaller on all sides */
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 1;
      pointer-events: none;
    }

    .card-image-frame-draggable {
      cursor: grab;
      user-select: none;
      border-radius: 0.25rem;
      overflow: visible;
      z-index: 3 !important; /* Layer 3: Image_bg (above background) */
    }

    .card-image-frame-draggable.dragging {
      cursor: grabbing;
    }

    .card-image-frame-draggable:hover {
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .card-image-frame-draggable .resize-handle {
      position: absolute;
      bottom: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 20 !important; /* Very high to ensure it's clickable */
      pointer-events: all;
      touch-action: none;
    }

    .card-image-frame-draggable .resize-handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
    }

    .card-image-frame-draggable:hover .resize-handle { opacity: 1; }

    .card-image-frame-draggable .rotate-handle {
      position: absolute;
      top: -15px;
      left: -15px;
      width: 24px;
      height: 24px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: grab;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 20 !important; /* Very high to ensure it's clickable */
      pointer-events: all;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-image-frame-draggable .rotate-handle::before {
      content: '↻';
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .card-image-frame-draggable:hover .rotate-handle { opacity: 1; }
    .card-image-frame-draggable.rotating .rotate-handle { cursor: grabbing; opacity: 1; }

    /* Mobile: Always show handles for touch interaction */
    @media (max-width: 768px) {
      .card-image-frame-draggable .resize-handle,
      .card-image-frame-draggable .rotate-handle {
        opacity: 1;
        width: 32px;
        height: 32px;
        pointer-events: all;
        touch-action: none;
      }
      .card-image-frame-draggable .resize-handle {
        bottom: -14px;
        right: -14px;
      }
      .card-image-frame-draggable .rotate-handle {
        top: -14px;
        left: -14px;
      }
      .card-image-frame-draggable .resize-handle::before {
        width: 10px;
        height: 10px;
      }
      .card-image-frame-draggable .rotate-handle::before {
        font-size: 18px;
      }
      .card-image-frame-draggable {
        touch-action: none;
      }
    }

    /* Layer 2: Draggable Photo */
    .card-photo-draggable {
      position: absolute;
      z-index: 4 !important; /* Layer 2: Image (above image_bg) */
      cursor: grab;
      user-select: none;
      border-radius: 0.25rem;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .card-photo-draggable img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
    }

    .card-photo-draggable:hover {
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .card-photo-draggable.dragging {
      cursor: grabbing;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }

    .card-photo-draggable .resize-handle {
      position: absolute;
      bottom: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 20 !important; /* Very high to ensure it's clickable */
      pointer-events: all;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-photo-draggable .resize-handle::before {
      content: '⤢';
      font-size: 12px;
      color: white;
      font-weight: bold;
    }

    .card-photo-draggable:hover .resize-handle { opacity: 1; }

    .card-photo-draggable .rotate-handle {
      position: absolute;
      top: -15px;
      left: -15px;
      width: 20px;
      height: 20px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: grab;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 20 !important; /* Very high to ensure it's clickable */
      pointer-events: all;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-photo-draggable .rotate-handle::before {
      content: '↻';
      font-size: 13px;
      color: white;
      font-weight: bold;
    }

    .card-photo-draggable:hover .rotate-handle { opacity: 1; }
    .card-photo-draggable.rotating .rotate-handle { cursor: grabbing; opacity: 1; }

    /* Mobile: Always show handles for touch interaction */
    @media (max-width: 768px) {
      .card-photo-draggable .resize-handle,
      .card-photo-draggable .rotate-handle {
        opacity: 1;
        width: 32px;
        height: 32px;
        pointer-events: all;
        touch-action: none;
      }
      .card-photo-draggable .resize-handle { 
        bottom: -14px; 
        right: -14px; 
      }
      .card-photo-draggable .rotate-handle { 
        top: -14px; 
        left: -14px; 
      }
      .card-photo-draggable .resize-handle::before { font-size: 16px; }
      .card-photo-draggable .rotate-handle::before { font-size: 18px; }
      .card-photo-draggable {
        touch-action: none;
      }
    }

    /* Layer 4: Content Overlay (title, subtitle, stickers) */
    .card-content-overlay {
      position: absolute;
      inset: 0;
      z-index: 3;
      display: flex;
      flex-direction: column;
      padding: 1.75rem 1.25rem;
      pointer-events: none;
    }

    .card-content-overlay .card-title {
      flex-shrink: 0;
    }

    .card-content-overlay .card-photo-placeholder-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-content-overlay .card-subtitle {
      flex-shrink: 0;
    }

    .card-content-overlay > * {
      pointer-events: auto;
    }

    .card-content {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 1.75rem 1.25rem;
      overflow: hidden;
    }

    .card-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: 1.5rem;
      font-weight: 300;
      color: white;
      text-align: center;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      margin-top: 0;
      margin-bottom: 0;
      letter-spacing: 1px;
    }

    /* Title size options */
    .card-title.size-small { font-size: 1.1rem; }
    .card-title.size-mid { font-size: 1.5rem; }
    .card-title.size-big { font-size: 2rem; }

    /* Title color options */
    .card-title.color-white { 
      color: white; 
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    .card-title.color-black { 
      color: #1a1a1a; 
      text-shadow: 0 1px 3px rgba(255, 255, 255, 0.3);
    }

    /* Title font weight options */
    .card-title.weight-normal { font-weight: 300; }
    .card-title.weight-bold { font-weight: 700; }

    /* Title font style options */
    .card-title.style-normal { font-style: normal; }
    .card-title.style-italic { font-style: italic; }

    /* Font style selector buttons */
    .style-selector {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .style-btn {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: white;
      border: 2px solid var(--main-pink);
      border-radius: 0.4rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text-dark);
    }

    /* Smaller style buttons (5px smaller) */
    .style-selector.small {
      gap: 0.35rem;
      margin-top: 0.35rem;
    }

    .style-selector.small .style-btn {
      padding: 0.35rem 0.5rem;
      font-size: 0.6rem;
      border-radius: 0.3rem;
    }

    .style-btn:hover {
      border-color: var(--main-red);
      background: var(--main-pink);
    }

    .style-btn.active {
      border-color: var(--main-red);
      background: var(--main-red);
      color: white;
    }

    .style-btn.color-preview-white {
      background: white;
      color: #333;
    }

    .style-btn.color-preview-black {
      background: #1a1a1a;
      color: white;
    }

    .style-btn.color-preview-white.active,
    .style-btn.color-preview-black.active {
      border-color: var(--main-red);
      box-shadow: 0 0 0 2px var(--main-red);
    }

    .card-photo-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
    }

    .card-photo-frame {
      background: white;
      padding: 5px;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
    }

    .card-photo-frame img {
      display: block;
      max-width: 220px;
      max-height: 280px;
      object-fit: contain;
    }

    .card-photo-placeholder {
      width: 160px;
      height: 210px;
      background: rgba(255, 255, 255, 0.12);
      border: 2px dashed rgba(255, 255, 255, 0.25);
      border-radius: 0.4rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.4);
      margin: 0 auto;
      align-self: center;
    }

    .card-photo-placeholder .icon { font-size: 1.75rem; margin-bottom: 0.4rem; }
    .card-photo-placeholder .text { font-size: 0.7rem; }

    .card-subtitle {
      font-family: 'Cormorant Garamond', serif;
      font-style: italic;
      font-size: 0.9rem;
      color: white;
      text-align: center;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      margin-top: auto;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    /* Subtitle/Message size options */
    .card-subtitle.size-small { font-size: 0.7rem; }
    .card-subtitle.size-mid { font-size: 0.9rem; }
    .card-subtitle.size-big { font-size: 1.1rem; }

    /* Subtitle/Message color options */
    .card-subtitle.color-white { 
      color: white; 
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    .card-subtitle.color-black { 
      color: #1a1a1a; 
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
    }

    /* Subtitle/Message font weight options */
    .card-subtitle.weight-normal { font-weight: 400; }
    .card-subtitle.weight-bold { font-weight: 700; }

    /* Subtitle/Message font style options */
    .card-subtitle.style-normal { font-style: normal; }
    .card-subtitle.style-italic { font-style: italic; }

    .card-sticker {
      position: absolute;
      cursor: grab;
      user-select: none;
      transition: transform 0.1s;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      z-index: 5 !important; /* Layer 1: Stickers (topmost) */
    }

    .card-sticker img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }

    .card-sticker:hover { transform: scale(1.05); }
    .card-sticker.dragging { cursor: grabbing; }
    .card-sticker.resizing { cursor: nwse-resize; }

    .card-sticker .delete-x {
      position: absolute;
      top: -8px;
      right: -8px;
      background: rgba(220, 38, 38, 0.9);
      color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .card-sticker:hover .delete-x { opacity: 1; }

    .card-sticker .resize-handle {
      position: absolute;
      bottom: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: nwse-resize;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 21 !important; /* Above sticker */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card-sticker .resize-handle::before {
      content: '⤢';
      font-size: 12px;
      color: white;
      font-weight: bold;
    }

    .card-sticker:hover .resize-handle { opacity: 1; }

    .card-sticker .rotate-handle {
      position: absolute;
      bottom: -24px;
      left: 50%;
      width: 20px;
      height: 20px;
      background: var(--main-red);
      border: 2px solid white;
      border-radius: 50%;
      cursor: grab;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 21 !important; /* Above sticker */
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
    }

    .card-sticker .rotate-handle::before {
      content: '↻';
      font-size: 13px;
      color: white;
      font-weight: bold;
    }

    .card-sticker:hover .rotate-handle { opacity: 1; }
    .card-sticker.rotating .rotate-handle { cursor: grabbing; opacity: 1; }

    /* Mobile: Always show handles for touch interaction */
    @media (max-width: 768px) {
      .card-sticker .resize-handle,
      .card-sticker .rotate-handle {
        opacity: 1;
        width: 28px;
        height: 28px;
      }
      .card-sticker .resize-handle { bottom: -12px; right: -12px; }
      .card-sticker .rotate-handle { bottom: -32px; }
      .card-sticker .resize-handle::before { font-size: 14px; }
      .card-sticker .rotate-handle::before { font-size: 16px; }
    }

    .empty-preview {
      text-align: center;
      color: var(--text-light);
      max-width: 600px;
      margin: 0 auto;
      padding: 0 20px;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .empty-preview .icon { font-size: 3.5rem; margin-bottom: 1rem; opacity: 0.4; }

    .empty-preview h2 {
      font-family: 'Cormorant Garamond', serif;
      font-weight: 400;
      font-size: 1.4rem;
      margin-bottom: 0.4rem;
    }

    .empty-preview p { font-size: 0.8rem; opacity: 0.6; }

    /* ========== PREVIEW MODE (After Finish) ========== */
    .preview-mode {
      min-height: 100vh;
      background: var(--secondary-white);
      padding: 2rem;
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
      overflow-y: auto; /* Enable vertical scrolling */
      box-sizing: border-box;
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1000px;
      margin: 0 auto 2rem;
      padding: 0 20px;
      flex-wrap: wrap;
      gap: 1rem;
    }

    @media (max-width: 768px) {
      .preview-mode {
        padding: 15px;
        padding-bottom: 80px; /* Extra space at bottom for scrolling */
        min-height: auto;
        height: auto;
      }
      .preview-header {
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
        margin-bottom: 1.5rem;
      }
      .preview-header h1 {
        font-size: 1.2rem;
      }
      .preview-header p {
        font-size: 0.8rem;
      }
    }

    .preview-header h1 {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 1.8rem;
      color: var(--main-red);
      letter-spacing: 0.5px;
      text-transform: uppercase;
      max-width: 600px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      margin: 0;
    }

    .preview-header p {
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-dark);
      margin-top: 0.5rem;
      max-width: 600px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      letter-spacing: 0.3px;
    }

    @media (max-width: 768px) {
      .preview-header h1 {
        font-size: 1.3rem;
      }
    }

    .header-buttons {
      display: flex;
      gap: 0.75rem;
    }

    .share-btn {
      padding: 0.7rem 1.5rem;
      background: var(--accent-aqua);
      border: none;
      border-radius: 2rem;
      color: var(--text-dark);
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(174, 238, 238, 0.3);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .share-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(174, 238, 238, 0.4);
    }

    .edit-btn {
      padding: 0.7rem 1.5rem;
      background: white;
      border: 2px solid var(--main-red);
      border-radius: 2rem;
      color: var(--text-dark);
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .edit-btn:hover {
      background: var(--main-red);
      color: white;
    }

    /* Artwork Grid */
    .artwork-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
      max-width: 900px;
      margin: 0 auto;
      padding: 0 20px;
      width: 100%;
      box-sizing: border-box;
    }

    @media (max-width: 768px) {
      .artwork-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
        padding: 0 10px;
        padding-bottom: 20px;
      }
    }

    @media (max-width: 480px) {
      .artwork-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
        padding: 0 5px;
        padding-bottom: 20px;
      }
    }

    .artwork-card {
      position: relative;
      aspect-ratio: 1;
      cursor: pointer;
      transition: transform 0.3s ease;
    }

    .artwork-card:hover {
      transform: scale(1.05);
    }

    .artwork-card:hover .artwork-image {
      animation: giggle 0.4s ease-in-out;
    }

    @keyframes giggle {
      0%, 100% { transform: rotate(0deg); }
      20% { transform: rotate(-3deg); }
      40% { transform: rotate(3deg); }
      60% { transform: rotate(-2deg); }
      80% { transform: rotate(2deg); }
    }

    .artwork-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.2));
      transition: transform 0.3s;
    }

    .artwork-card.revealed .artwork-image {
      opacity: 0.3;
    }

    .artwork-day-label {
      position: absolute;
      bottom: -1.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Cormorant Garamond', serif;
      font-size: 0.9rem;
      color: var(--text-light);
      white-space: nowrap;
    }

    .artwork-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 0.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .artwork-card:hover .artwork-overlay {
      opacity: 1;
    }

    .artwork-overlay .scratch-hint {
      font-size: 0.85rem;
      font-weight: 600;
    }

    .artwork-card.revealed .artwork-overlay {
      opacity: 1;
      background: rgba(174, 238, 238, 0.8);
    }

    .lock-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 0.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
    }

    .lock-overlay .lock-icon { font-size: 2rem; margin-bottom: 0.5rem; }
    .lock-overlay .lock-text { font-size: 0.7rem; text-align: center; padding: 0 0.5rem; }

    /* ========== SHARE MODAL ========== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease;
    }

    /* Happy New Year modal should appear on top of everything */
    .happy-new-year-overlay {
      z-index: 3000 !important;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .share-modal {
      background: white;
      border-radius: 1rem;
      padding: 2rem;
      width: 90%;
      max-width: 450px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      position: relative;
    }

    @media (max-width: 768px) {
      .share-modal {
        padding: 1.5rem;
        max-height: 90vh;
      }
      .share-link-section {
        margin-bottom: 1.5rem;
      }
      .share-link-section h3 {
        font-size: 0.9rem;
      }
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .modal-close:hover { opacity: 1; }

    /* ========== HAPPY NEW YEAR MODAL ========== */
    .happy-new-year-popup-container {
      max-width: 90%;
      max-height: 80vh;
      position: relative;
      animation: popupGrowAndSwing 1.5s ease-out forwards;
      filter: drop-shadow(0 25px 50px rgba(0, 0, 0, 0.4));
      cursor: pointer;
      z-index: 10;
      transform-origin: center center;
      display: inline-block;
    }

    .happy-new-year-popup-image {
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 80vh;
      object-fit: contain;
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      display: block;
    }

    /* First image sets the container size - make it relative and visible initially */
    .happy-new-year-popup-image:first-child {
      position: relative;
      opacity: 1;
      animation: popupCard1 1.6s ease-in-out infinite;
    }

    /* Animation for cycling through popupcard1-4 - each image shows for 25% of the cycle */
    .happy-new-year-popup-image:nth-child(1) {
      animation: popupCard1 1.6s ease-in-out infinite;
    }

    .happy-new-year-popup-image:nth-child(2) {
      animation: popupCard2 1.6s ease-in-out infinite;
    }

    .happy-new-year-popup-image:nth-child(3) {
      animation: popupCard3 1.6s ease-in-out infinite;
    }

    .happy-new-year-popup-image:nth-child(4) {
      animation: popupCard4 1.6s ease-in-out infinite;
    }

    @keyframes popupCard1 {
      0%, 24% { opacity: 1; }
      25%, 100% { opacity: 0; }
    }

    @keyframes popupCard2 {
      0%, 24% { opacity: 0; }
      25%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    @keyframes popupCard3 {
      0%, 49% { opacity: 0; }
      50%, 74% { opacity: 1; }
      75%, 100% { opacity: 0; }
    }

    @keyframes popupCard4 {
      0%, 74% { opacity: 0; }
      75%, 99% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Growing animation + swing - starts small, grows, then swings */
    @keyframes popupGrowAndSwing {
      0% {
        opacity: 0;
        transform: scale(0.1) rotate(0deg);
      }
      30% {
        opacity: 1;
        transform: scale(1.1) rotate(0deg);
      }
      40% {
        transform: scale(1) rotate(0deg);
      }
      /* Swing left */
      50% {
        transform: scale(1) rotate(-8deg);
      }
      /* Swing right */
      60% {
        transform: scale(1) rotate(8deg);
      }
      /* Swing left smaller */
      70% {
        transform: scale(1) rotate(-5deg);
      }
      /* Swing right smaller */
      80% {
        transform: scale(1) rotate(5deg);
      }
      /* Swing left tiny */
      90% {
        transform: scale(1) rotate(-2deg);
      }
      /* Settle */
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }

    /* Fade out animation for closing */
    .happy-new-year-overlay.closing {
      animation: fadeOut 0.3s ease forwards;
    }

    .happy-new-year-overlay.closing .happy-new-year-popup-container {
      animation: popupShrink 0.3s ease forwards;
    }

    .happy-new-year-overlay.closing .happy-new-year-popup-image {
      animation: none;
      opacity: 0;
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @keyframes popupShrink {
      from { 
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      to { 
        opacity: 0;
        transform: scale(0.5) rotate(-10deg);
      }
    }

    /* ========== HEARTS ANIMATION ========== */
    .hearts-container {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floating-heart {
      position: absolute;
      pointer-events: none;
      z-index: 5;
      /* Heart will burst outward from center */
      animation: burstHeart 2.5s ease-out forwards;
    }

    /* Clear heart shape using SVG background */
    .floating-heart::before {
      content: '';
      display: block;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23E4412D'%3E%3Cpath d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
    }

    /* Heart sizes: mini, small, mid */
    .floating-heart.size-mini::before {
      width: 10px;
      height: 10px;
    }
    .floating-heart.size-small::before {
      width: 16px;
      height: 16px;
    }
    .floating-heart.size-mid::before {
      width: 22px;
      height: 22px;
    }

    /* Burst animation - explode outward from center */
    @keyframes burstHeart {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(0.3);
      }
      30% {
        opacity: 1;
        transform: translate(var(--tx), var(--ty)) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(calc(var(--tx) * 2), calc(var(--ty) * 2)) scale(0.6);
      }
    }

    @media (max-width: 768px) {
      .happy-new-year-popup-container {
        max-width: 95%;
      }
    }

    .share-modal h2 {
      font-family: 'Cormorant Garamond', serif;
      font-weight: 400;
      font-size: 1.5rem;
      color: var(--text-dark);
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .share-modal p {
      font-size: 0.85rem;
      color: var(--text-light);
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .share-link-section {
      margin-bottom: 1rem;
    }

    .share-link-section h3 {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 1rem;
      color: var(--text-dark);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .link-description {
      font-size: 0.8rem !important;
      color: var(--text-light) !important;
      text-align: left !important;
      margin-bottom: 1rem !important;
    }

    .share-url-box {
      background: var(--secondary-white);
      border: 1px solid var(--main-pink);
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      word-break: break-all;
      font-size: 0.75rem;
      color: var(--text-dark);
      max-height: 80px;
      overflow-y: auto;
    }

    .copy-btn {
      width: 100%;
      padding: 0.85rem;
      background: var(--main-red);
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .copy-btn:hover {
      transform: scale(1.02);
    }

    .copy-btn.copied {
      background: var(--success);
    }

    /* ========== DATE PICKER MODAL ========== */
    .date-modal {
      background: var(--secondary-white);
      border-radius: 1rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 380px;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      position: relative;
    }

    .date-modal h2 {
      font-family: 'Quicksand', sans-serif;
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--text-dark);
      margin-bottom: 1rem;
      text-align: center;
      text-transform: uppercase;
    }

    .date-input-wrapper {
      margin-bottom: 1rem;
    }

    .date-input-wrapper label {
      display: block;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      color: var(--text-light);
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .date-input-wrapper input[type="date"] {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid var(--main-pink);
      border-radius: 0.5rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.9rem;
      color: var(--text-dark);
      background: white;
      transition: all 0.2s;
    }

    .date-input-wrapper input[type="date"]:focus {
      outline: none;
      border-color: var(--main-red);
      box-shadow: 0 0 0 3px rgba(254, 213, 212, 0.3);
    }

    .date-preview {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      color: var(--text-light);
      text-align: center;
      margin-bottom: 1.25rem;
      line-height: 1.6;
    }

    .date-preview strong {
      color: var(--text-dark);
    }

    .confirm-date-btn {
      width: 100%;
      padding: 0.85rem;
      background: var(--main-red);
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .confirm-date-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(228, 65, 45, 0.4);
    }

    .confirm-date-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* ========== CAMERA PERMISSION MODAL ========== */
    .camera-permission-modal {
      background: var(--secondary-white);
      border-radius: 1rem;
      padding: 2rem;
      width: 90%;
      max-width: 320px;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
      animation: slideUp 0.3s ease;
      position: relative;
    }

    .camera-permission-modal p {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.9rem;
      color: var(--text-dark);
      text-align: center;
      margin-bottom: 1.5rem;
      line-height: 1.5;
    }

    .camera-permission-buttons {
      display: flex;
      gap: 0.75rem;
    }

    .permission-btn {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 0.5rem;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
    }

    .permission-btn.no {
      background: white;
      border: 2px solid var(--main-pink);
      color: var(--text-dark);
    }

    .permission-btn.no:hover {
      background: var(--main-pink);
    }

    .permission-btn.yes {
      background: var(--main-red);
      color: white;
    }

    .permission-btn.yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(228, 65, 45, 0.4);
    }

    /* ========== CAMERA VIEWFINDER ========== */
    .camera-viewfinder {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease;
    }

    .camera-video-container {
      position: relative;
      width: 90%;
      max-width: 600px;
      aspect-ratio: 4/3;
      background: #000;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(255, 255, 255, 0.1);
    }

    .camera-video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-controls {
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .camera-capture-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: 4px solid white;
      background: var(--main-red);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .camera-capture-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(228, 65, 45, 0.6);
    }

    .camera-capture-btn:active {
      transform: scale(0.95);
    }

    .camera-close-btn {
      padding: 0.75rem 1.5rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      border-radius: 2rem;
      color: white;
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
    }

    .camera-close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ========== SCRATCH OVERLAY ========== */
    .scratch-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      padding: 20px;
    }

    .scratch-container {
      position: relative;
      z-index: 10;
    }

    @media (max-width: 480px) {
      .scratch-overlay {
        padding: 10px;
      }
      .scratch-canvas {
        max-width: 90vw;
        max-height: 70vh;
      }
    }

    .scratch-underlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    .scratch-underlay.visible {
      opacity: 1;
    }

    .scratch-canvas {
      display: block;
      cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='37' height='37' viewBox='0 0 100 100' fill='%23E4412D'%3E%3Cpath d='M50 10c-8 0-15 4-18 12l-8 20c-3 5-3 11 0 16l5 12c2 3 5 5 8 5h12c3 0 6-2 8-5l5-12c3-5 3-11 0-16l-8-20c-3-8-10-12-18-12zm-20 30c-4 0-7 3-7 7v20c0 4 3 7 7 7h40c4 0 7-3 7-7V47c0-4-3-7-7-7H30zm-8 30c-3 0-5 2-5 5v15c0 3 2 5 5 5h56c3 0 5-2 5-5V75c0-3-2-5-5-5H22z'/%3E%3C/svg%3E") 18.5 18.5, auto;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      position: relative;
      z-index: 10;
    }

    .scratch-progress {
      text-align: center;
      margin-top: 1rem;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.85rem;
    }

    .close-scratch {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      transition: background 0.2s;
      z-index: 10;
    }

    .close-scratch:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ========== REVEAL COMPLETE ========== */
    .reveal-complete {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      overflow-y: auto;
      padding: 20px;
    }

    .reveal-complete .card-preview {
      animation: revealPop 0.5s ease-out;
    }

    @media (max-width: 480px) {
      .reveal-complete {
        padding: 15px;
      }
    }

    @keyframes revealPop {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .reveal-complete .hint {
      position: absolute;
      bottom: 2rem;
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.8rem;
    }

    /* Hearts Glitter Effect (for scratch reveal) */
    .glitter-container {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1001;
    }

    .glitter-heart {
      position: absolute;
      animation: glitterBurst 2s ease-out forwards;
    }

    /* Clear heart shape using SVG for glitter */
    .glitter-heart::before {
      content: '';
      display: block;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23E4412D'%3E%3Cpath d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
    }

    /* Glitter heart sizes */
    .glitter-heart.size-mini::before {
      width: 8px;
      height: 8px;
    }
    .glitter-heart.size-small::before {
      width: 12px;
      height: 12px;
    }
    .glitter-heart.size-mid::before {
      width: 18px;
      height: 18px;
    }

    /* Burst animation for scratch glitter */
    @keyframes glitterBurst {
      0% { 
        opacity: 1; 
        transform: translate(0, 0) scale(0.3); 
      }
      30% {
        opacity: 1;
        transform: translate(var(--tx), var(--ty)) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translate(calc(var(--tx) * 1.5), calc(var(--ty) * 1.5)) scale(0.5); 
      }
    }

    /* Scrollbar */
    .panel-content::-webkit-scrollbar { width: 4px; }
    .panel-content::-webkit-scrollbar-track { background: var(--pink-light); }
    .panel-content::-webkit-scrollbar-thumb { background: var(--pink); border-radius: 2px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ========== CONFIG ==========
    const DAYS_CONFIG = [
      { id: 1, emoji: '🤠', artwork: 'artwork1.png' },
      { id: 2, emoji: '🧣', artwork: 'artwork2.png' },
      { id: 3, emoji: '👧', artwork: 'artwork3.png' },
      { id: 4, emoji: '👢', artwork: 'artwork4.png' },
      { id: 5, emoji: '🐴', artwork: 'artwork5.png' },
      { id: 6, emoji: '🍀', artwork: 'artwork6.png' },
    ];

    const TEMPLATES = [
      { id: 'template1', icon: '', label: 'Template 1', bgColor: '#FED5D4', pattern: 'stars-pattern', image: 'template1.jpg' },
      { id: 'template2', icon: '', label: 'Template 2', bgColor: '#F9F0F0', pattern: '', image: 'template2.jpg' },
      { id: 'template3', icon: '', label: 'Template 3', bgColor: '#AEEEEE', pattern: 'clovers-pattern', image: 'template4.jpg' },
      { id: 'template4', icon: '', label: 'Template 4', bgColor: '#FED5D4', pattern: 'hearts-pattern', image: 'template4-1.jpg' },
    ];

    const STICKERS = [
      'stickers/sticker.png', 'stickers/sticker2.png', 'stickers/sticker3.png', 'stickers/sticker4.PNG', 
      'stickers/sticker5.PNG', 'stickers/sticker6.PNG', 'stickers/sticker7.PNG', 'stickers/sticker8.PNG', 
      'stickers/sticker9.PNG', 'stickers/sticker10.png', 'stickers/sticker11.png', 'stickers/sticker12.png',
      'stickers/sticker13.png', 'stickers/sticker14.png'
    ];

    // Image backgrounds (middle layer - photo frames)
    const IMAGE_BGS = [
      { id: 'imageBg1', image: 'image_bg_1.png', label: 'Frame 1' },
      { id: 'imageBg2', image: 'image_bg_2.png', label: 'Frame 2' },
      { id: 'imageBg3', image: 'image_bg_3.png', label: 'Frame 3' },
      { id: 'imageBg4', image: 'image_bg_4.png', label: 'Frame 4' },
      { id: 'imageBg5', image: 'image_bg_5.png', label: 'Frame 5' },
      { id: 'imageBg6', image: 'image_bg_6.png', label: 'Frame 6' },
    ];

    // ========== UTILITIES ==========
    function isCardLocked(dayNumber, startDate) {
      if (!startDate) return false;
      const start = new Date(startDate);
      start.setHours(0, 0, 0, 0);
      const unlockDate = new Date(start);
      unlockDate.setDate(start.getDate() + (dayNumber - 1));
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return today < unlockDate;
    }

    function getUnlockDate(dayNumber, startDate) {
      if (!startDate) return null;
      const start = new Date(startDate);
      const unlockDate = new Date(start);
      unlockDate.setDate(start.getDate() + (dayNumber - 1));
      return unlockDate;
    }

    function formatDate(date) {
      if (!date) return '';
      return new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    // Compress image to reduce size (max 100KB)
    async function compressImage(base64Image, maxSizeKB = 100) {
      if (!base64Image || !base64Image.startsWith('data:image')) return base64Image;
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          
          // Scale down if too large
          const maxDimension = 400;
          if (width > maxDimension || height > maxDimension) {
            if (width > height) {
              height = (height / width) * maxDimension;
              width = maxDimension;
            } else {
              width = (width / height) * maxDimension;
              height = maxDimension;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          
          // Compress with lower quality
          resolve(canvas.toDataURL('image/jpeg', 0.5));
        };
        img.onerror = () => resolve(base64Image);
        img.src = base64Image;
      });
    }

    // Compress all images in session data
    async function compressSessionData(data) {
      const compressed = JSON.parse(JSON.stringify(data));
      for (const key in compressed.cards) {
        if (compressed.cards[key].photo) {
          compressed.cards[key].photo = await compressImage(compressed.cards[key].photo);
        }
      }
      return compressed;
    }

    // Generate a unique ID for storing data
    function generateUniqueId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    }

    // Store data to jsonbox.io (free, no auth required, CORS friendly)
    async function storeData(data) {
      try {
        // Use jsonbox.io - free JSON storage with no authentication
        const boxId = 'lny_gift_cards_2024'; // Shared box for all users
        const response = await fetch(`https://jsonbox.io/${boxId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        });
        
        if (response.ok) {
          const result = await response.json();
          // jsonbox returns _id for the record
          if (result && result._id) {
            return result._id;
          }
        }
        throw new Error('Failed to store data');
      } catch (error) {
        console.error('Storage error:', error);
        return null;
      }
    }

    // Fetch data from jsonbox.io by ID
    async function fetchData(recordId) {
      try {
        const boxId = 'lny_gift_cards_2024';
        const response = await fetch(`https://jsonbox.io/${boxId}/${recordId}`);
        
        if (response.ok) {
          const result = await response.json();
          return result;
        }
        throw new Error('Failed to fetch data');
      } catch (error) {
        console.error('Fetch error:', error);
        return null;
      }
    }

    // Generate SHARE link (for recipients to scratch - read-only)
    async function generateShareURL(giftData) {
      // Compress images first
      const compressedData = await compressSessionData(giftData);
      const pasteId = await storeData({ type: 'gift', data: compressedData });
      if (pasteId) {
        const baseUrl = window.location.origin + window.location.pathname;
        return `${baseUrl}?id=${pasteId}`;
      }
      // If storage fails, show error message
      return 'Error: Could not generate share link. Please try again.';
    }

    // Generate EDIT link (for creator to continue editing)
    async function generateEditURL(sessionData) {
      // Compress images first
      const compressedData = await compressSessionData(sessionData);
      const pasteId = await storeData({ type: 'edit', data: compressedData });
      if (pasteId) {
        const baseUrl = window.location.origin + window.location.pathname;
        return `${baseUrl}?id=${pasteId}`;
      }
      // If storage fails, show error message
      return 'Error: Could not generate edit link. Please try again.';
    }

    // Parse URL parameters - check for 'id' (new short), 'gift', or 'edit' (legacy)
    async function parseGiftFromURL() {
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get('id');
      const giftParam = params.get('gift');
      const editParam = params.get('edit');
      
      // New short URL format with paste ID
      if (idParam) {
        const stored = await fetchData(idParam);
        if (stored) {
          if (stored.type === 'edit') {
            localStorage.setItem('lnyGiftSession', JSON.stringify(stored.data));
            return { type: 'edit', data: null };
          } else if (stored.type === 'gift') {
            return { type: 'gift', data: stored.data };
          }
        }
      }
      
      // Legacy: If 'edit' param exists, load session for editing
      if (editParam) {
        try {
          const sessionData = JSON.parse(decodeURIComponent(escape(atob(editParam))));
          localStorage.setItem('lnyGiftSession', JSON.stringify(sessionData));
          return { type: 'edit', data: null };
        } catch (e) {
          console.error('Failed to parse edit data');
        }
      }
      
      // Legacy: If 'gift' param exists, load for recipient (read-only)
      if (giftParam) {
        try {
          return { type: 'gift', data: JSON.parse(decodeURIComponent(escape(atob(giftParam)))) };
        } catch (e) {
          console.error('Failed to parse gift data');
        }
      }
      
      return null;
    }

    // ========== MAIN APP ==========
    function App() {
      const [isLoading, setIsLoading] = useState(true);
      const [giftData, setGiftData] = useState(null);
      const [isRecipientMode, setIsRecipientMode] = useState(false);

      // Modes: 'editor', 'preview'
      const [mode, setMode] = useState('editor');
      const [editorView, setEditorView] = useState('list');
      const [editingDay, setEditingDay] = useState(null);
      
      // Share modal
      const [showShareModal, setShowShareModal] = useState(false);
      const [shareURL, setShareURL] = useState('');
      const [editURL, setEditURL] = useState('');
      const [copied, setCopied] = useState('');
      const [copiedType, setCopiedType] = useState(''); // 'share' or 'edit'
      const [isGeneratingLink, setIsGeneratingLink] = useState(false);
      
      // Date picker modal
      const [showDateModal, setShowDateModal] = useState(false);
      const [tempStartDate, setTempStartDate] = useState('');
      
      // Camera modals
      const [showCameraView, setShowCameraView] = useState(false);
      const [cameraStream, setCameraStream] = useState(null);
      const videoRef = useRef(null);

      // Mobile panel state
      const [mobilePanelOpen, setMobilePanelOpen] = useState(false);

      // Default session data
      const getDefaultSession = () => ({
        startDate: '',
        cards: {
          1: { template: 'template1', imageBg: 'imageBg1', title: 'I LOVE YOU', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'ADD A SELFIE OF YOU AND SHOW YOUR LOVE !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
          2: { template: 'template2', imageBg: 'imageBg2', title: 'THIS IS MY PLAY LIST !', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SHARE A PLAYLIST WITH YOUR FRIEND!', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
          3: { template: 'template3', imageBg: 'imageBg3', title: 'The Lucky Charm', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SEND YOUR FRIEND A HORSE IMAGE WISH THEM A GOOD LUCK IN THE YEAR OF THE HORSE !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
          4: { template: 'template4', imageBg: 'imageBg4', title: 'A LITTLE GIFT FROM ME', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SEND THEM A DIGITAL GIFT CARD !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
          5: { template: 'template1', imageBg: 'imageBg5', title: 'A LITTLE MESSAGE FROM ME', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'INPUT YOUR VIDEO TO SPICE IT UP', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
          6: { template: 'template2', imageBg: 'imageBg6', title: 'THIS IS MY TREAT', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'A LITTLE DATE WITH ME SAVED!', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
        }
      });

      // Session data
      const [session, setSession] = useState(() => {
        const saved = localStorage.getItem('lnyGiftSession');
        if (saved) {
          try { return JSON.parse(saved); } catch (e) {}
        }
        return getDefaultSession();
      });

      // Load data from URL on mount
      useEffect(() => {
        const loadFromURL = async () => {
          const result = await parseGiftFromURL();
          if (result) {
            if (result.type === 'gift' && result.data) {
              setGiftData(result.data);
              setSession(result.data);
              setIsRecipientMode(true);
              setMode('preview');
            } else if (result.type === 'edit') {
              // Data was stored in localStorage by parseGiftFromURL
              const saved = localStorage.getItem('lnyGiftSession');
              if (saved) {
                try { 
                  setSession(JSON.parse(saved)); 
                } catch (e) {}
              }
              setMode('editor');
            }
          }
          setIsLoading(false);
        };
        loadFromURL();
      }, []);

      // Revealed cards
      const [revealedCards, setRevealedCards] = useState(() => {
        const saved = localStorage.getItem('lnyRevealedCards');
        if (saved) {
          try { return JSON.parse(saved); } catch (e) {}
        }
        return {};
      });

      // Scratch overlay
      const [scratchingDay, setScratchingDay] = useState(null);
      const [viewingDay, setViewingDay] = useState(null);
      
      // Happy New Year modal
      const [showHappyNewYear, setShowHappyNewYear] = useState(false);
      const [isClosing, setIsClosing] = useState(false);

      const currentCard = editingDay ? session.cards[editingDay] : null;

      const updateCard = (field, value) => {
        if (!editingDay) return;
        setSession(prev => ({
          ...prev,
          cards: {
            ...prev.cards,
            [editingDay]: { ...prev.cards[editingDay], [field]: value }
          }
        }));
      };

      const updateStartDate = (date) => {
        setSession(prev => ({ ...prev, startDate: date }));
      };

      const handleSelectDay = (dayId) => {
        setEditingDay(dayId);
        setEditorView('edit');
        // Don't auto-open panel - user will click the arrow tab to open it
      };

      const handleBackToList = () => {
        if (editingDay && currentCard) {
          const hasContent = currentCard.title || currentCard.photo || currentCard.emojis.length > 0;
          updateCard('completed', hasContent);
        }
        setEditorView('list');
        setEditingDay(null);
      };

      // Navigate to previous card
      const handlePreviousCard = () => {
        if (editingDay && editingDay > 1) {
          const previousDay = editingDay - 1;
          handleSelectDay(previousDay);
        }
      };

      const handleSaveCard = () => {
        updateCard('completed', true);
        localStorage.setItem('lnyGiftSession', JSON.stringify(session));
        
        // Go to next card if available
        const nextDay = editingDay + 1;
        if (nextDay <= 6) {
          setEditingDay(nextDay);
          setEditorView('edit');
          // Open mobile panel when navigating to next card on mobile
          if (window.innerWidth <= 768) {
            setMobilePanelOpen(true);
          }
        } else {
          // Last card completed - show date picker on desktop, go to list on mobile
          if (window.innerWidth > 768) {
            // Desktop: Show date picker modal
            setTempStartDate(session.startDate || '');
            setShowDateModal(true);
          } else {
            // Mobile: Go back to list
            handleBackToList();
          }
        }
        setMobilePanelOpen(false); // Close mobile panel after saving
      };

      // FINISH & GENERATE
      const handleFinish = () => {
        setTempStartDate(session.startDate || '');
        setShowDateModal(true);
      };

      // Confirm date and generate
      const handleConfirmDate = async () => {
        if (!tempStartDate) return;
        
        setIsGeneratingLink(true);
        
        const updatedSession = {
          ...session,
          startDate: tempStartDate
        };
        
        setSession(updatedSession);
        localStorage.setItem('lnyGiftSession', JSON.stringify(updatedSession));
        
        // Generate both links (async)
        const [shareLink, editLink] = await Promise.all([
          generateShareURL(updatedSession),
          generateEditURL(updatedSession)
        ]);
        
        setShareURL(shareLink);
        setEditURL(editLink);
        setIsGeneratingLink(false);
        setShowDateModal(false);
        setMode('preview');
      };

      // Get unlock date preview
      const getUnlockPreview = (dayNumber) => {
        if (!tempStartDate) return '';
        const start = new Date(tempStartDate);
        const unlockDate = new Date(start);
        unlockDate.setDate(start.getDate() + (dayNumber - 1));
        return unlockDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      };

      // Open share modal
      const handleOpenShare = async () => {
        setIsGeneratingLink(true);
        setShowShareModal(true);
        
        // Generate both links (async)
        const [shareLink, editLink] = await Promise.all([
          generateShareURL(session),
          generateEditURL(session)
        ]);
        
        setShareURL(shareLink);
        setEditURL(editLink);
        setIsGeneratingLink(false);
      };

      // Copy link (either share or edit)
      const handleCopyLink = (type) => {
        const urlToCopy = type === 'edit' ? editURL : shareURL;
        navigator.clipboard.writeText(urlToCopy);
        setCopiedType(type);
        setCopied(urlToCopy);
        setTimeout(() => {
          setCopied('');
          setCopiedType('');
        }, 2000);
      };

      // Scratch card click
      const handleArtworkClick = (dayId) => {
        if (isCardLocked(dayId, session.startDate)) return;
        if (revealedCards[dayId]) {
          setViewingDay(dayId);
        } else {
          setScratchingDay(dayId);
        }
      };

      // Create floating hearts effect - burst from center
      const createFloatingHearts = () => {
        const container = document.querySelector('.hearts-container');
        if (!container) return;
        
        // Clear any existing hearts
        container.innerHTML = '';
        
        // Heart sizes: mini, small, mid
        const sizes = ['size-mini', 'size-small', 'size-mid'];
        
        // Create 27 hearts (10% less than 30) bursting from center
        for (let i = 0; i < 27; i++) {
          setTimeout(() => {
            const heart = document.createElement('div');
            const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
            heart.className = `floating-heart ${randomSize}`;
            
            // Random angle for burst direction (360 degrees)
            const angle = (Math.random() * 360) * (Math.PI / 180);
            const distance = 100 + Math.random() * 200; // How far to burst
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;
            
            // Set CSS variables for burst direction
            heart.style.setProperty('--tx', `${tx}px`);
            heart.style.setProperty('--ty', `${ty}px`);
            heart.style.animationDelay = Math.random() * 0.3 + 's';
            heart.style.animationDuration = (2 + Math.random() * 1) + 's';
            
            container.appendChild(heart);
            
            // Remove heart after animation
            setTimeout(() => heart.remove(), 4000);
          }, i * 40); // Faster stagger for explosion effect
        }
      };

      // Check if all cards are revealed
      const checkAllCardsRevealed = (revealed) => {
        const allRevealed = DAYS_CONFIG.every(day => revealed[day.id] === true);
        if (allRevealed) {
          // Check if popup has already been shown (only show once)
          const popupShownKey = 'lnyHappyNewYearShown';
          const hasBeenShown = localStorage.getItem(popupShownKey) === 'true';
          
          if (!hasBeenShown) {
            // Show popup after a short delay so user can see the last card first
            setTimeout(() => {
              setShowHappyNewYear(true);
              setIsClosing(false);
              // Create hearts effect
              setTimeout(createFloatingHearts, 100);
              // Mark as shown so it only appears once
              localStorage.setItem(popupShownKey, 'true');
            }, 1500); // 1.5 second delay
          }
        }
      };

      // Close Happy New Year popup with animation
      const handleCloseHappyNewYear = useCallback(() => {
        setIsClosing(true);
        // Wait for animation to complete before hiding
        setTimeout(() => {
          setShowHappyNewYear(false);
          setIsClosing(false);
          setViewingDay(null); // Reset to original view (cards grid)
        }, 300); // Match animation duration
      }, []);

      // Escape key handler
      useEffect(() => {
        const handleEscape = (e) => {
          if (e.key === 'Escape' && showHappyNewYear) {
            handleCloseHappyNewYear();
          }
        };
        window.addEventListener('keydown', handleEscape);
        return () => window.removeEventListener('keydown', handleEscape);
      }, [showHappyNewYear, handleCloseHappyNewYear]);

      // Scratch complete
      const handleScratchComplete = (dayId) => {
        const newRevealed = { ...revealedCards, [dayId]: true };
        setRevealedCards(newRevealed);
        localStorage.setItem('lnyRevealedCards', JSON.stringify(newRevealed));
        setScratchingDay(null);
        setViewingDay(dayId);
        // Check if all cards are revealed - popup will appear automatically
        checkAllCardsRevealed(newRevealed);
      };

      const fileInputRef = useRef(null);

      const [isConvertingPhoto, setIsConvertingPhoto] = useState(false);

      // Test if browser can display an image
      const canDisplayImage = (blob) => {
        return new Promise((resolve) => {
          const img = new Image();
          const url = URL.createObjectURL(blob);
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(true);
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve(false);
          };
          img.src = url;
        });
      };

      const handlePhotoUpload = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        
        // Check if file is HEIC/HEIF format
        const isHeic = file.type === 'image/heic' || 
                       file.type === 'image/heif' || 
                       file.name.toLowerCase().endsWith('.heic') || 
                       file.name.toLowerCase().endsWith('.heif');
        
        console.log('File selected:', file.name, 'Type:', file.type, 'Is HEIC:', isHeic);
        
        setIsConvertingPhoto(true);
        
        // First, try to display the image directly (Safari supports HEIC natively)
        const canDisplay = await canDisplayImage(file);
        console.log('Browser can display directly:', canDisplay);
        
        if (canDisplay) {
          // Browser supports this format natively
          const reader = new FileReader();
          reader.onload = (event) => {
            updateCard('photo', event.target.result);
            setSession(prev => ({ ...prev }));
            if (fileInputRef.current) fileInputRef.current.value = '';
            setIsConvertingPhoto(false);
          };
          reader.onerror = () => {
            console.error('Error reading file');
            setIsConvertingPhoto(false);
          };
          reader.readAsDataURL(file);
          return;
        }
        
        // Browser can't display natively, try to convert HEIC
        if (isHeic) {
          // Check if heic2any is available
          if (typeof heic2any === 'undefined') {
            alert('你的瀏覽器不支援 HEIC 格式。\n\n解決方法：\n1. 使用 Safari 瀏覽器（原生支援 HEIC）\n2. 或者先把照片轉成 JPG/PNG 格式再上傳');
            setIsConvertingPhoto(false);
            if (fileInputRef.current) fileInputRef.current.value = '';
            return;
          }
          
          try {
            console.log('Starting HEIC conversion...');
            const convertedBlob = await heic2any({
              blob: file,
              toType: 'image/jpeg',
              quality: 0.85,
            });
            
            const resultBlob = Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob;
            const blobUrl = URL.createObjectURL(resultBlob);
            
            updateCard('photo', blobUrl);
            setSession(prev => ({ ...prev }));
            if (fileInputRef.current) fileInputRef.current.value = '';
            setIsConvertingPhoto(false);
            console.log('HEIC conversion successful');
          } catch (error) {
            console.error('HEIC conversion failed:', error);
            alert('無法轉換此 HEIC 圖片。\n\n解決方法：\n1. 使用 Safari 瀏覽器（原生支援 HEIC）\n2. 在 iPhone 設定 > 相機 > 格式，選擇「最相容」\n3. 或者用其他 App 把照片轉成 JPG 再上傳');
            setIsConvertingPhoto(false);
            if (fileInputRef.current) fileInputRef.current.value = '';
          }
        } else {
          // Non-HEIC file that browser can't display (shouldn't happen often)
          alert('無法顯示此圖片格式，請使用 JPG 或 PNG。');
          setIsConvertingPhoto(false);
          if (fileInputRef.current) fileInputRef.current.value = '';
        }
      };

      const handleUploadClick = (e) => {
        // On desktop, let the label handle it naturally, but ensure input is clickable
        // Only programmatically click if the input isn't already being triggered
        if (fileInputRef.current && !fileInputRef.current.matches(':focus')) {
          e.preventDefault();
          fileInputRef.current.click();
        }
      };

      // Camera handlers
      const handleCameraClick = async (e) => {
        e.preventDefault();
        try {
          // Request camera access directly (browser will show permission prompt)
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment' } 
          });
          setCameraStream(stream);
          setShowCameraView(true);
          // Set video source after a brief delay to ensure ref is ready
          setTimeout(() => {
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
            }
          }, 100);
        } catch (err) {
          console.error('Camera access denied:', err);
          alert('Camera access was denied. Please allow camera access to take photos.');
        }
      };

      const handleCapturePhoto = () => {
        if (videoRef.current) {
          const canvas = document.createElement('canvas');
          canvas.width = videoRef.current.videoWidth;
          canvas.height = videoRef.current.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(videoRef.current, 0, 0);
          const dataURL = canvas.toDataURL('image/png');
          updateCard('photo', dataURL);
          handleCloseCamera();
        }
      };

      const handleCloseCamera = () => {
        if (cameraStream) {
          cameraStream.getTracks().forEach(track => track.stop());
          setCameraStream(null);
        }
        setShowCameraView(false);
      };

      // Set up video stream when camera view opens
      useEffect(() => {
        if (showCameraView && cameraStream && videoRef.current) {
          videoRef.current.srcObject = cameraStream;
        }
      }, [showCameraView, cameraStream]);

      // Cleanup camera stream on unmount
      useEffect(() => {
        return () => {
          if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
          }
        };
      }, [cameraStream]);

      // Check if all cards are revealed on mount or when revealedCards changes
      useEffect(() => {
        if (mode === 'preview' && !showHappyNewYear) {
          const allRevealed = DAYS_CONFIG.every(day => revealedCards[day.id] === true);
          if (allRevealed) {
            // Check if popup has already been shown (only show once)
            const popupShownKey = 'lnyHappyNewYearShown';
            const hasBeenShown = localStorage.getItem(popupShownKey) === 'true';
            
            if (!hasBeenShown) {
              // Show immediately on mount if all cards are already revealed
              setShowHappyNewYear(true);
              setIsClosing(false);
              // Create hearts effect after DOM updates
              setTimeout(createFloatingHearts, 100);
              // Mark as shown so it only appears once
              localStorage.setItem(popupShownKey, 'true');
            }
          }
        }
      }, [mode, revealedCards, showHappyNewYear]);

      const addSticker = (stickerPath) => {
        if (!editingDay) return;
        const newSticker = {
          id: Date.now(),
          image: stickerPath,
          x: 40 + Math.random() * 160,
          y: 80 + Math.random() * 260,
          width: 60,
          height: 60,
          rotation: 0,
        };
        updateCard('emojis', [...(currentCard.emojis || []), newSticker]);
      };

      const updateStickerPos = (stickerId, x, y) => {
        if (!editingDay) return;
        updateCard('emojis', currentCard.emojis.map(e => 
          e.id === stickerId ? { ...e, x, y } : e
        ));
      };

      const updateStickerSize = (stickerId, width, height) => {
        if (!editingDay) return;
        updateCard('emojis', currentCard.emojis.map(e => 
          e.id === stickerId ? { ...e, width, height } : e
        ));
      };

      const updateStickerRotation = (stickerId, rotation) => {
        if (!editingDay) return;
        updateCard('emojis', currentCard.emojis.map(e => 
          e.id === stickerId ? { ...e, rotation } : e
        ));
      };

      const deleteSticker = (stickerId) => {
        if (!editingDay) return;
        updateCard('emojis', currentCard.emojis.filter(e => e.id !== stickerId));
      };

      // Photo transform functions
      const updatePhotoTransform = (updates) => {
        if (!editingDay) return;
        const currentTransform = currentCard.photoTransform || { x: 50, y: 50, width: 180, height: 180, rotation: 0 };
        updateCard('photoTransform', { ...currentTransform, ...updates });
      };

      const updateImageFrameTransform = (updates) => {
        if (!editingDay) return;
        const currentTransform = currentCard.imageFrameTransform || { width: 350, height: 350, rotation: 0 };
        updateCard('imageFrameTransform', { ...currentTransform, ...updates });
      };

      const currentTemplate = currentCard 
        ? TEMPLATES.find(t => t.id === currentCard.template) 
        : null;

      // ========== LOADING STATE ==========
      if (isLoading) {
        return (
          <div className="app-container" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh', flexDirection: 'column' }}>
            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>🎁</div>
            <p style={{ color: 'var(--accent-primary)', fontFamily: 'Cormorant Garamond, serif' }}>Loading your gift...</p>
          </div>
        );
      }

      // ========== PREVIEW MODE ==========
      if (mode === 'preview') {
        return (
          <>
            <div className="preview-mode">
              <div className="preview-header">
                <div>
                  <h1>Your Gift Cards</h1>
                  <p>Scratch each artwork to reveal your surprise</p>
                </div>
                <div className="header-buttons">
                  {!isRecipientMode && (
                    <>
                      <button className="share-btn" onClick={handleOpenShare}>
                        Share
                      </button>
                      <button className="edit-btn" onClick={() => {
                        // Clear all saved data and restart
                        localStorage.removeItem('lnyGiftSession');
                        localStorage.removeItem('lnyRevealedCards');
                        localStorage.removeItem('lnyHappyNewYearShown'); // Reset popup flag
                        setRevealedCards({});
                        setShowHappyNewYear(false); // Reset popup state
                        setSession({
                          startDate: '',
                          cards: {
                            1: { template: 'template1', imageBg: 'imageBg1', title: 'I LOVE YOU', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'ADD A SELFIE OF YOU AND SHOW YOUR LOVE !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                            2: { template: 'template2', imageBg: 'imageBg2', title: 'THIS IS MY PLAY LIST !', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SHARE A PLAYLIST WITH YOUR FRIEND!', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                            3: { template: 'template3', imageBg: 'imageBg3', title: 'The Lucky Charm', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SEND YOUR FRIEND A HORSE IMAGE WISH THEM A GOOD LUCK IN THE YEAR OF THE HORSE !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                            4: { template: 'template4', imageBg: 'imageBg4', title: 'A LITTLE GIFT FROM ME', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'SEND THEM A DIGITAL GIFT CARD !', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                            5: { template: 'template1', imageBg: 'imageBg5', title: 'A LITTLE MESSAGE FROM ME', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'INPUT YOUR VIDEO TO SPICE IT UP', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                            6: { template: 'template2', imageBg: 'imageBg6', title: 'THIS IS MY TREAT', titleSize: 'mid', titleColor: 'white', titleBold: false, titleItalic: false, subtitle: 'A LITTLE DATE WITH ME SAVED!', subtitleSize: 'mid', subtitleColor: 'white', subtitleBold: false, subtitleItalic: true, photo: null, photoTransform: { x: 50, y: 50, width: 180, height: 180, rotation: 0 }, imageFrameTransform: { width: 350, height: 350, rotation: 0 }, emojis: [], completed: false },
                          }
                        });
                        setMode('editor');
                      }}>
                        Restart
                      </button>
                    </>
                  )}
                </div>
              </div>

              <div className="artwork-grid">
                {DAYS_CONFIG.map(day => {
                  const isLocked = isCardLocked(day.id, session.startDate);
                  const isRevealed = revealedCards[day.id];

                  return (
                    <div
                      key={day.id}
                      className={`artwork-card ${isRevealed ? 'revealed' : ''}`}
                      onClick={() => handleArtworkClick(day.id)}
                    >
                      <img src={day.artwork} alt={`Day ${day.id}`} className="artwork-image" />
                      <span className="artwork-day-label">Day {day.id}</span>
                      
                      {isLocked ? (
                        <div className="lock-overlay">
                          <span className="lock-icon">🔒</span>
                          <span className="lock-text">
                            Unlocks {formatDate(getUnlockDate(day.id, session.startDate))}
                          </span>
                        </div>
                      ) : !isRevealed ? (
                        <div className="artwork-overlay">
                          <span className="scratch-hint">Scratch Me!</span>
                        </div>
                      ) : (
                        <div className="artwork-overlay">
                          <span className="scratch-hint">Tap to View</span>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Share Modal */}
            {showShareModal && (
              <div className="modal-overlay" onClick={() => setShowShareModal(false)}>
                <div className="share-modal" onClick={(e) => e.stopPropagation()}>
                  <button className="modal-close" onClick={() => setShowShareModal(false)}>×</button>
                  <h2>Share Your Gift</h2>
                  
                  {isGeneratingLink ? (
                    <div style={{ textAlign: 'center', padding: '2rem' }}>
                      <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>✨</div>
                      <p>Creating your short share link...</p>
                    </div>
                  ) : (
                    <>
                      {/* Share Link (for recipients) */}
                      <div className="share-link-section">
                        <h3>📤 Share Link (For Your Friends)</h3>
                        <p className="link-description">Send this short link to your friend so they can scratch and reveal your surprises!</p>
                        <div className="share-url-box" style={{ wordBreak: 'break-all', fontSize: shareURL.length > 80 ? '0.7rem' : '0.85rem' }}>{shareURL}</div>
                        <button 
                          className={`copy-btn ${copiedType === 'share' ? 'copied' : ''}`} 
                          onClick={() => handleCopyLink('share')}
                        >
                          {copiedType === 'share' ? '✓ Copied!' : 'Copy Share Link'}
                        </button>
                      </div>

                      {/* Edit Link (for creator) */}
                      <div className="share-link-section" style={{ marginTop: '2rem', paddingTop: '2rem', borderTop: '1px solid rgba(0,0,0,0.1)' }}>
                        <h3>✏️ Edit Link (For You)</h3>
                        <p className="link-description">Save this link to continue editing your cards later!</p>
                        <div className="share-url-box" style={{ wordBreak: 'break-all', fontSize: editURL.length > 80 ? '0.7rem' : '0.85rem' }}>{editURL}</div>
                        <button 
                          className={`copy-btn ${copiedType === 'edit' ? 'copied' : ''}`} 
                          onClick={() => handleCopyLink('edit')}
                        >
                          {copiedType === 'edit' ? '✓ Copied!' : 'Copy Edit Link'}
                        </button>
                      </div>
                    </>
                  )}
                </div>
              </div>
            )}

            {/* Scratch Overlay */}
            {scratchingDay && (
              <ScratchOverlay
                day={scratchingDay}
                cardContent={session.cards[scratchingDay]}
                onComplete={() => handleScratchComplete(scratchingDay)}
                onClose={() => setScratchingDay(null)}
              />
            )}

            {/* View Revealed Card */}
            {viewingDay && (
              <div className="reveal-complete" onClick={() => setViewingDay(null)}>
                <CardPreview
                  content={session.cards[viewingDay]}
                  template={TEMPLATES.find(t => t.id === session.cards[viewingDay].template)}
                  readOnly
                  onImageFrameTransform={() => {}}
                />
                <span className="hint">Tap anywhere to close</span>
              </div>
            )}

            {/* Happy New Year Modal */}
            {showHappyNewYear && (
              <div 
                className={`modal-overlay happy-new-year-overlay ${isClosing ? 'closing' : ''}`}
                onClick={handleCloseHappyNewYear}
                style={{ cursor: 'pointer' }}
              >
                {/* Hearts Animation Container */}
                <div className="hearts-container" />
                <div className="happy-new-year-popup-container">
                  <img 
                    src="popupcard1.png" 
                    alt="Happy New Year!"
                    className="happy-new-year-popup-image"
                  />
                  <img 
                    src="popupcard2.png" 
                    alt="Happy New Year!"
                    className="happy-new-year-popup-image"
                  />
                  <img 
                    src="popupcard3.png" 
                    alt="Happy New Year!"
                    className="happy-new-year-popup-image"
                  />
                  <img 
                    src="popupcard4.png" 
                    alt="Happy New Year!"
                    className="happy-new-year-popup-image"
                  />
                </div>
              </div>
            )}

            {/* Attribution Footer */}
            <div className="attribution-footer">
              Made with <span className="heart">♥</span> by{' '}
              <a href="https://www.instagram.com/evelynn.creates_" target="_blank" rel="noopener noreferrer">
                evelynn.creates_
              </a>
            </div>
          </>
        );
      }

      // ========== EDITOR MODE ==========
      return (
        <div className="app-container">
          {/* Mobile toggle button - Create Your Card */}
          {editorView === 'list' && (
            <button 
              className="mobile-toggle-btn"
              onClick={() => handleSelectDay(1)}
            >
              Create Your Card
            </button>
          )}

          {/* Mobile card dots indicator - show when editing */}
          {editorView === 'edit' && editingDay && (
            <div className="mobile-card-dots">
              {[1, 2, 3, 4, 5, 6].map((day) => (
                <div
                  key={day}
                  className={`mobile-card-dot ${editingDay === day ? 'active' : ''}`}
                />
              ))}
            </div>
          )}

          {/* Mobile back button - show when editing and not on card 1 */}
          {editorView === 'edit' && editingDay && editingDay > 1 && !mobilePanelOpen && (
            <button 
              className="mobile-back-btn"
              onClick={handlePreviousCard}
            >
              ← BACK
            </button>
          )}

          {/* Mobile save button - only show in edit mode */}
          {editorView === 'edit' && !mobilePanelOpen && (
            <button 
              className="mobile-save-btn" 
              onClick={editingDay === 6 ? handleFinish : handleSaveCard}
            >
              {editingDay === 6 ? 'FINISH AND SEND' : 'SAVE →'}
            </button>
          )}

          {/* Mobile panel pull tab - always visible when editing */}
          {editorView === 'edit' && (
            <button
              className={`mobile-panel-tab ${mobilePanelOpen ? 'panel-open' : ''}`}
              onClick={() => setMobilePanelOpen(!mobilePanelOpen)}
              aria-label="Toggle editing panel"
            />
          )}

          {/* Mobile backdrop - show when panel is open */}
          {mobilePanelOpen && (
            <div 
              className="mobile-panel-backdrop visible"
              onClick={() => {
                setMobilePanelOpen(false);
              }}
            />
          )}

          <aside className={`left-panel ${mobilePanelOpen ? 'mobile-open' : ''}`}>
            <div className="panel-header">
              {editorView === 'edit' && (
                <button className="back-btn" onClick={handleBackToList}>←</button>
              )}
              <h1>{editorView === 'edit' ? DAYS_CONFIG.find(d => d.id === editingDay)?.emoji : 'EDIT YOUR CARDS!'}</h1>
              {editorView === 'list' && (
                <button 
                  className="start-fresh-btn" 
                  onClick={() => {
                    if (confirm('Start fresh? This will clear all your current designs.')) {
                      localStorage.removeItem('lnyGiftSession');
                      localStorage.removeItem('lnyRevealedCards');
                      localStorage.removeItem('lnyHappyNewYearShown');
                      setSession(getDefaultSession());
                      setRevealedCards({});
                    }
                  }}
                  title="Clear all and start fresh"
                >
                  🔄 New
                </button>
              )}
            </div>

            <div className="panel-content">
              {editorView === 'list' ? (
                <>
                  <div className="day-list">
                    {DAYS_CONFIG.map(day => (
                      <div
                        key={day.id}
                        className={`day-item ${session.cards[day.id].completed ? 'completed' : ''}`}
                        onClick={() => handleSelectDay(day.id)}
                      >
                        <div className="day-content">
                          <div className="day-label">CARD {day.id}</div>
                          <div className="status">TAP TO EDIT</div>
                        </div>
                        <span className="arrow"></span>
                      </div>
                    ))}
                  </div>
                </>
              ) : (
                <>
                  <div className="edit-section">
                    <h3>BACKGROUND</h3>
                    <div className="template-grid">
                      {TEMPLATES.map(template => (
                        <button
                          key={template.id}
                          className={`template-btn ${currentCard?.template === template.id ? 'active' : ''}`}
                          onClick={() => updateCard('template', template.id)}
                        >
                          <img src={template.image} alt={template.label} />
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="edit-section">
                    <h3>IMAGE FRAME</h3>
                    <div className="template-grid scrollable">
                      {IMAGE_BGS.map(bg => (
                        <button
                          key={bg.id}
                          className={`template-btn ${currentCard?.imageBg === bg.id ? 'active' : ''}`}
                          onClick={() => updateCard('imageBg', bg.id)}
                        >
                          <img src={bg.image} alt={bg.label} />
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="edit-section">
                    <h3>TITLE</h3>
                    <div className="input-group">
                      <input
                        type="text"
                        value={currentCard?.title || ''}
                        onChange={(e) => updateCard('title', e.target.value)}
                        placeholder="Enter title..."
                      />
                    </div>
                    {/* Hidden styling options - kept for data compatibility */}
                  </div>

                  <div className="edit-section">
                    <h3>MESSAGE</h3>
                    <div className="input-group">
                      <textarea
                        value={currentCard?.subtitle || ''}
                        onChange={(e) => updateCard('subtitle', e.target.value)}
                        placeholder="Add a message..."
                      />
                    </div>
                    <div className="input-group">
                      <label>Size</label>
                      <div className="style-selector small">
                        <button 
                          className={`style-btn ${currentCard?.subtitleSize === 'small' ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleSize', 'small')}
                        >
                          Small
                        </button>
                        <button 
                          className={`style-btn ${currentCard?.subtitleSize === 'mid' || !currentCard?.subtitleSize ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleSize', 'mid')}
                        >
                          Mid
                        </button>
                        <button 
                          className={`style-btn ${currentCard?.subtitleSize === 'big' ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleSize', 'big')}
                        >
                          Big
                        </button>
                      </div>
                    </div>
                    <div className="input-group">
                      <label>Color</label>
                      <div className="style-selector small">
                        <button 
                          className={`style-btn color-preview-white ${currentCard?.subtitleColor === 'white' || !currentCard?.subtitleColor ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleColor', 'white')}
                        >
                          White
                        </button>
                        <button 
                          className={`style-btn color-preview-black ${currentCard?.subtitleColor === 'black' ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleColor', 'black')}
                        >
                          Black
                        </button>
                      </div>
                    </div>
                    <div className="input-group">
                      <label>Style</label>
                      <div className="style-selector small">
                        <button 
                          className={`style-btn ${currentCard?.subtitleBold ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleBold', !currentCard?.subtitleBold)}
                          style={{ fontWeight: 'bold' }}
                        >
                          B
                        </button>
                        <button 
                          className={`style-btn ${currentCard?.subtitleItalic ? 'active' : ''}`}
                          onClick={() => updateCard('subtitleItalic', !currentCard?.subtitleItalic)}
                          style={{ fontStyle: 'italic', fontFamily: 'serif' }}
                        >
                          I
                        </button>
                      </div>
                    </div>
                  </div>

                  <div className="edit-section">
                    <h3>PHOTO</h3>
                    <div className="photo-options">
                      <label className="photo-upload-area" htmlFor="photo-upload-input-label" style={{ opacity: isConvertingPhoto ? 0.6 : 1, pointerEvents: isConvertingPhoto ? 'none' : 'auto' }}>
                        <span className="upload-text">
                          {isConvertingPhoto ? '轉換中...' : (currentCard?.photo ? 'CHANGE' : 'UPLOAD')}
                        </span>
                        <input 
                          ref={fileInputRef}
                          id="photo-upload-input-label"
                          type="file" 
                          accept="image/*,.heic,.heif"
                          onChange={handlePhotoUpload}
                          disabled={isConvertingPhoto}
                          style={{ position: 'absolute', width: '1px', height: '1px', padding: 0, margin: '-1px', overflow: 'hidden', clip: 'rect(0,0,0,0)', border: 0 }}
                        />
                      </label>
                      <div className="photo-camera-area" onClick={handleCameraClick} style={{ opacity: isConvertingPhoto ? 0.6 : 1, pointerEvents: isConvertingPhoto ? 'none' : 'auto' }}>
                        <div className="camera-text">
                          {currentCard?.photo ? 'RETAKE' : 'CAMERA'}
                        </div>
                      </div>
                    </div>
                    {currentCard?.photo && (
                      <div className="photo-preview-box">
                        <img src={currentCard.photo} alt="Preview" />
                        <button className="remove-btn" onClick={() => updateCard('photo', null)}>✕</button>
                      </div>
                    )}
                  </div>

                  <div className="edit-section">
                    <h3>Stickers</h3>
                    <div className="emoji-grid">
                      {STICKERS.map((sticker, i) => (
                        <button key={i} className="emoji-btn" onClick={() => addSticker(sticker)}>
                          <img src={sticker} alt={`Sticker ${i + 1}`} style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                        </button>
                      ))}
                    </div>
                  </div>
                </>
              )}
            </div>

            <div className="panel-footer">
              {editorView === 'list' ? (
                <button className="btn-primary btn-gold" onClick={handleFinish}>
                  PREVIEW AND SEND
                </button>
              ) : (
                <button className="btn-primary" onClick={editingDay === 6 ? () => {
                  handleSaveCard();
                } : handleSaveCard}>
                  {editingDay === 6 ? 'FINISH AND SEND' : `Save Day ${editingDay} →`}
                </button>
              )}
            </div>
          </aside>

          <main className="right-panel">
            {editorView !== 'edit' && (
              <>
                <div className="right-panel-text top-right">
                  A Little Sparkle for Someone Special
                </div>
                <div className="right-panel-text bottom-left">
                  From My Heart<br />to Your Screen.
                </div>
                <div className="mobile-list-hint">
                  <h1 className="headline">Scratch into the New Year! 🐎</h1>
                  <p className="sub-headline">Design your own digital lucky card. Scratch, wish, and share the joy with friends and family.</p>
                </div>
              </>
            )}
            {editorView === 'edit' && currentCard && (
              <CardPreview
                content={currentCard}
                template={currentTemplate}
                onStickerMove={updateStickerPos}
                onStickerResize={updateStickerSize}
                onStickerRotate={updateStickerRotation}
                onStickerDelete={deleteSticker}
                onPhotoTransform={updatePhotoTransform}
                onImageFrameTransform={updateImageFrameTransform}
              />
            )}
          </main>

          {/* Date Picker Modal */}
          {showDateModal && (
            <div className="modal-overlay" onClick={() => setShowDateModal(false)}>
              <div className="date-modal" onClick={(e) => e.stopPropagation()}>
                <button className="modal-close" onClick={() => setShowDateModal(false)}>×</button>
                <h2>Set Start Date</h2>
                <div className="date-input-wrapper">
                  <label>Start Date</label>
                  <input
                    type="date"
                    value={tempStartDate}
                    onChange={(e) => setTempStartDate(e.target.value)}
                  />
                </div>
                {tempStartDate && (
                  <div className="date-preview">
                    <strong>Card 1</strong> will unlock on {getUnlockPreview(1)}.<br />
                    <strong>Card 2</strong> will unlock on {getUnlockPreview(2)}.
                  </div>
                )}
                <button
                  className="confirm-date-btn"
                  onClick={handleConfirmDate}
                  disabled={!tempStartDate}
                >
                  Confirm
                </button>
              </div>
            </div>
          )}

          {/* Camera Viewfinder */}
          {showCameraView && (
            <div className="camera-viewfinder">
              <div className="camera-video-container">
                <video
                  ref={videoRef}
                  autoPlay
                  playsInline
                  style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                />
              </div>
              <div className="camera-controls">
                <button className="camera-close-btn" onClick={handleCloseCamera}>
                  CLOSE
                </button>
                <button className="camera-capture-btn" onClick={handleCapturePhoto}>
                  <div style={{ width: '50px', height: '50px', borderRadius: '50%', background: 'white' }}></div>
                </button>
              </div>
            </div>
          )}

          {/* Attribution Footer */}
          <div className="attribution-footer">
            Made with <span className="heart">♥</span> by{' '}
            <a href="https://www.instagram.com/evelynn.creates_" target="_blank" rel="noopener noreferrer">
              evelynn.creates_
            </a>
          </div>
        </div>
      );
    }

    // ========== SCRATCH OVERLAY ==========
    function ScratchOverlay({ day, cardContent, onComplete, onClose }) {
      const canvasRef = useRef(null);
      const [progress, setProgress] = useState(0);
      const [isScratching, setIsScratching] = useState(false);
      const [artworkLoaded, setArtworkLoaded] = useState(false);
      const [cardVisible, setCardVisible] = useState(false);

      const dayConfig = DAYS_CONFIG.find(d => d.id === day);
      const template = TEMPLATES.find(t => t.id === cardContent.template);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          // Use artwork's natural size, but limit max dimensions
          const maxWidth = Math.min(img.width, 400);
          const maxHeight = Math.min(img.height, 550);
          const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
          
          canvas.width = img.width * scale;
          canvas.height = img.height * scale;
          
          // Draw full artwork without cropping
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          
          setArtworkLoaded(true);
        };
        img.src = dayConfig.artwork;
      }, [day]);

      const scratch = (x, y) => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, 25, 0, Math.PI * 2);
        ctx.fill();
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let transparent = 0;
        for (let i = 3; i < imageData.data.length; i += 4) {
          if (imageData.data[i] === 0) transparent++;
        }
        const total = imageData.data.length / 4;
        const newProgress = Math.round((transparent / total) * 100);
        setProgress(newProgress);
        
        // Show card at 50%
        if (newProgress >= 50 && !cardVisible) {
          setCardVisible(true);
        }
        
        // Complete at 80%
        if (newProgress >= 80) {
          createGlitter();
          setTimeout(onComplete, 500);
        }
      };

      const handleMouseMove = (e) => {
        if (!isScratching || !artworkLoaded) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        scratch(x, y);
      };

      const handleTouchMove = (e) => {
        if (!artworkLoaded) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvasRef.current.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        scratch(x, y);
      };

      const createGlitter = () => {
        const container = document.createElement('div');
        container.className = 'glitter-container';
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.justifyContent = 'center';
        document.body.appendChild(container);
        
        // Heart sizes: mini, small, mid
        const sizes = ['size-mini', 'size-small', 'size-mid'];
        
        // Create 22 hearts (10% less) bursting from center
        for (let i = 0; i < 22; i++) {
          const heart = document.createElement('div');
          const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
          heart.className = `glitter-heart ${randomSize}`;
          
          // Random angle for burst direction (360 degrees)
          const angle = (Math.random() * 360) * (Math.PI / 180);
          const distance = 80 + Math.random() * 150;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;
          
          // Set CSS variables for burst direction
          heart.style.setProperty('--tx', `${tx}px`);
          heart.style.setProperty('--ty', `${ty}px`);
          heart.style.animationDelay = Math.random() * 0.2 + 's';
          container.appendChild(heart);
        }
        
        setTimeout(() => container.remove(), 2500);
        
      };

      return (
        <div className="scratch-overlay">
          <button className="close-scratch" onClick={onClose}>✕</button>
          
          <div className={`scratch-underlay ${cardVisible ? 'visible' : ''}`}>
          <CardPreview content={cardContent} template={template} readOnly onImageFrameTransform={() => {}} />
        </div>
        
        <div className="scratch-container">
            <canvas
              ref={canvasRef}
              className="scratch-canvas"
              onMouseDown={() => setIsScratching(true)}
              onMouseUp={() => setIsScratching(false)}
              onMouseLeave={() => setIsScratching(false)}
              onMouseMove={handleMouseMove}
              onTouchStart={() => setIsScratching(true)}
              onTouchEnd={() => setIsScratching(false)}
              onTouchMove={handleTouchMove}
            />
            
            <div className="scratch-progress">
              {progress < 50 
                ? `Keep scratching: ${progress}%` 
                : progress < 80 
                  ? `Almost there: ${progress}%` 
                  : 'Revealed!'}
            </div>
          </div>
        </div>
      );
    }

    // ========== CARD PREVIEW ==========
    function CardPreview({ content, template, onStickerMove, onStickerResize, onStickerRotate, onStickerDelete, onPhotoTransform, onImageFrameTransform, readOnly }) {
      if (!content || !template) return null;

      // Find the image background
      const imageBgConfig = IMAGE_BGS.find(bg => bg.id === content.imageBg);
      const photoTransform = content.photoTransform || { x: 50, y: 50, width: 180, height: 180, rotation: 0 };
      // Use imageFrameTransform if provided, otherwise let component auto-center (no x/y)
      const imageFrameTransform = content.imageFrameTransform || { width: 350, height: 350, rotation: 0 };

      return (
        <div 
          className={`card-preview ${template.pattern}`}
          style={{ 
            backgroundImage: template.image ? `url(${template.image})` : 'none',
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundColor: template.bgColor
          }}
        >
          {/* Layer 2: User's Photo (draggable/resizable/rotatable) */}
          {content.photo && (
            <DraggablePhoto
              photo={content.photo}
              transform={photoTransform}
              onTransform={readOnly ? () => {} : onPhotoTransform}
              readOnly={readOnly}
            />
          )}

          {/* Layer 3: Image Frame (middle layer) - draggable/resizable */}
          {imageBgConfig && (
            <DraggableImageFrame
              image={imageBgConfig.image}
              transform={imageFrameTransform}
              onTransform={readOnly ? () => {} : onImageFrameTransform}
              readOnly={readOnly}
            />
          )}

          {/* Layer 4: Content overlay (title, subtitle, stickers) */}
          <div className="card-content-overlay">
            <h2 className={`card-title size-${content.titleSize || 'mid'} color-${content.titleColor || 'white'} weight-${content.titleBold ? 'bold' : 'normal'} style-${content.titleItalic ? 'italic' : 'normal'}`}>
              {content.title}
            </h2>

            <div className="card-photo-placeholder-wrapper">
              {!content.photo && (
                <div className="card-photo-placeholder">
                  <span className="text">Upload photo</span>
                </div>
              )}
            </div>

            {content.subtitle && (
              <p className={`card-subtitle size-${content.subtitleSize || 'mid'} color-${content.subtitleColor || 'white'} weight-${content.subtitleBold ? 'bold' : 'normal'} style-${content.subtitleItalic ? 'italic' : 'normal'}`}>
                {content.subtitle}
              </p>
            )}

            {content.emojis?.map(sticker => (
              <DraggableSticker
                key={sticker.id}
                sticker={sticker}
                onMove={readOnly ? () => {} : (x, y) => onStickerMove(sticker.id, x, y)}
                onResize={readOnly ? () => {} : (w, h) => onStickerResize(sticker.id, w, h)}
                onRotate={readOnly ? () => {} : (rotation) => onStickerRotate(sticker.id, rotation)}
                onDelete={readOnly ? () => {} : () => onStickerDelete(sticker.id)}
                readOnly={readOnly}
              />
            ))}
          </div>
        </div>
      );
    }

    // ========== DRAGGABLE PHOTO ==========
    function DraggablePhoto({ photo, transform, onTransform, readOnly }) {
      const [isDragging, setIsDragging] = useState(false);
      const [isResizing, setIsResizing] = useState(false);
      const [isRotating, setIsRotating] = useState(false);
      const [position, setPosition] = useState({ x: transform.x || 50, y: transform.y || 120 });
      const [size, setSize] = useState({ width: transform.width || 180, height: transform.height || 180 });
      const [rotation, setRotation] = useState(transform.rotation || 0);
      const elementRef = useRef(null);
      const dragOffsetRef = useRef({ x: 0, y: 0 });
      const resizeStartRef = useRef({ x: 0, y: 0, width: 0, height: 0 });
      const rotateStartRef = useRef({ x: 0, y: 0, angle: 0, centerX: 0, centerY: 0 });

      // Get clientX/Y from mouse or touch event
      const getClientCoords = (e) => {
        if (e.touches && e.touches.length > 0) {
          return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
        }
        return { clientX: e.clientX, clientY: e.clientY };
      };

      const handleStart = (e, isTouch = false) => {
        if (readOnly) return;
        const target = e.target;
        const { clientX, clientY } = getClientCoords(e);
        
        // Check what we're interacting with first
        const isResizeHandle = target.classList.contains('resize-handle') || target.closest('.resize-handle');
        const isRotateHandle = target.classList.contains('rotate-handle') || target.closest('.rotate-handle');
        const isHandle = isResizeHandle || isRotateHandle;
        
        // Prevent default for all touch interactions
        if (isTouch) {
          e.preventDefault();
          e.stopPropagation();
        } else if (isHandle) {
          e.preventDefault();
        }
        
        if (isResizeHandle) {
          setIsResizing(true);
          const rect = elementRef.current.getBoundingClientRect();
          resizeStartRef.current = { x: clientX, y: clientY, width: rect.width, height: rect.height };
          return;
        }
        if (isRotateHandle) {
          setIsRotating(true);
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          rotateStartRef.current = { x: clientX, y: clientY, angle: rotation, centerX, centerY };
          return;
        }
        setIsDragging(true);
        const rect = elementRef.current.getBoundingClientRect();
        dragOffsetRef.current = { x: clientX - rect.left, y: clientY - rect.top };
      };

      const handleMouseDown = (e) => handleStart(e, false);
      const handleTouchStart = (e) => {
        // Prevent default immediately for touch to avoid scrolling
        e.preventDefault();
        e.stopPropagation();
        handleStart(e, true);
      };

      const handleMove = useCallback((e) => {
        const { clientX, clientY } = getClientCoords(e);
        
        if (isRotating) {
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const startDx = rotateStartRef.current.x - rotateStartRef.current.centerX;
          const startDy = rotateStartRef.current.y - rotateStartRef.current.centerY;
          const currentDx = clientX - centerX;
          const currentDy = clientY - centerY;
          const startAngle = Math.atan2(startDy, startDx) * (180 / Math.PI);
          const currentAngle = Math.atan2(currentDy, currentDx) * (180 / Math.PI);
          let deltaAngle = currentAngle - startAngle;
          if (deltaAngle > 180) deltaAngle -= 360;
          else if (deltaAngle < -180) deltaAngle += 360;
          const rotationSensitivity = 0.15;
          deltaAngle *= rotationSensitivity;
          let newRotation = rotateStartRef.current.angle + deltaAngle;
          newRotation = ((newRotation % 360) + 360) % 360;
          setRotation(newRotation);
        } else if (isResizing) {
          const deltaX = clientX - resizeStartRef.current.x;
          const deltaY = clientY - resizeStartRef.current.y;
          let newWidth = Math.max(50, resizeStartRef.current.width + deltaX);
          let newHeight = Math.max(50, resizeStartRef.current.height + deltaY);
          newWidth = Math.min(newWidth, 280);
          newHeight = Math.min(newHeight, 400);
          setSize({ width: newWidth, height: newHeight });
        } else if (isDragging) {
          const parent = elementRef.current.parentElement;
          const parentRect = parent.getBoundingClientRect();
          let newX = clientX - parentRect.left - dragOffsetRef.current.x;
          let newY = clientY - parentRect.top - dragOffsetRef.current.y;
          setPosition({ x: newX, y: newY });
        }
      }, [isDragging, isResizing, isRotating]);

      const handleEnd = useCallback(() => {
        if (isDragging) {
          setIsDragging(false);
          onTransform({ x: position.x, y: position.y });
        }
        if (isResizing) {
          setIsResizing(false);
          onTransform({ width: size.width, height: size.height });
        }
        if (isRotating) {
          setIsRotating(false);
          onTransform({ rotation });
        }
      }, [isDragging, isResizing, isRotating, position, size, rotation, onTransform]);

      useEffect(() => {
        if (isDragging || isResizing || isRotating) {
          const handleMouseMove = (e) => handleMove(e);
          const handleTouchMove = (e) => { e.preventDefault(); handleMove(e); };
          
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mouseup', handleEnd);
          window.addEventListener('touchmove', handleTouchMove, { passive: false });
          window.addEventListener('touchend', handleEnd);
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleEnd);
            window.removeEventListener('touchmove', handleTouchMove);
            window.removeEventListener('touchend', handleEnd);
          };
        }
      }, [isDragging, isResizing, isRotating, handleMove, handleEnd]);

      return (
        <div
          ref={elementRef}
          className={`card-photo-draggable ${isDragging ? 'dragging' : ''} ${isResizing ? 'resizing' : ''} ${isRotating ? 'rotating' : ''}`}
          style={{
            left: position.x,
            top: position.y,
            width: size.width,
            height: size.height,
            transform: `rotate(${rotation}deg)`,
            touchAction: 'none',
          }}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
        >
          <img src={photo} alt="Your photo" draggable={false} />
          {!readOnly && (
            <>
              <div className="resize-handle"></div>
              <div className="rotate-handle" style={{ transform: `rotate(${-rotation}deg)` }}></div>
            </>
          )}
        </div>
      );
    }

    // ========== DRAGGABLE IMAGE FRAME ==========
    function DraggableImageFrame({ image, transform, onTransform, readOnly }) {
      const [isDragging, setIsDragging] = useState(false);
      const [isResizing, setIsResizing] = useState(false);
      const [isRotating, setIsRotating] = useState(false);
      const [size, setSize] = useState({ width: transform.width || 350, height: transform.height || 350 });
      const [rotation, setRotation] = useState(transform.rotation || 0);
      const elementRef = useRef(null);
      const dragOffsetRef = useRef({ x: 0, y: 0 });
      const resizeStartRef = useRef({ x: 0, y: 0, width: 0, height: 0 });
      const rotateStartRef = useRef({ x: 0, y: 0, angle: 0, centerX: 0, centerY: 0 });

      // Calculate centered position if not provided
      const calculateCenteredPosition = () => {
        if (elementRef.current) {
          const parent = elementRef.current.parentElement;
          if (parent) {
            const parentRect = parent.getBoundingClientRect();
            const frameWidth = size.width;
            const frameHeight = size.height;
            return {
              x: (parentRect.width - frameWidth) / 2,
              y: (parentRect.height - frameHeight) / 2
            };
          }
        }
        // Fallback: approximate center for 320px card with 350px frame
        return { x: -15, y: 105 };
      };

      const [position, setPosition] = useState(() => {
        if (transform.x !== undefined && transform.y !== undefined) {
          return { x: transform.x, y: transform.y };
        }
        // Use fallback for initial render
        return { x: -15, y: 105 };
      });

      // Update position when transform changes or component mounts
      useEffect(() => {
        if (transform.x === undefined || transform.y === undefined) {
          // Wait for DOM to be ready, then calculate center
          const timer = setTimeout(() => {
            const centered = calculateCenteredPosition();
            setPosition(centered);
          }, 10);
          return () => clearTimeout(timer);
        } else {
          setPosition({ x: transform.x, y: transform.y });
        }
      }, [transform.x, transform.y, size.width, size.height]);

      // Recalculate center on window resize
      useEffect(() => {
        if (transform.x === undefined || transform.y === undefined) {
          const handleResize = () => {
            const centered = calculateCenteredPosition();
            setPosition(centered);
          };
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }
      }, [transform.x, transform.y, size.width, size.height]);

      const getClientCoords = (e) => {
        if (e.touches && e.touches.length > 0) {
          return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
        }
        return { clientX: e.clientX, clientY: e.clientY };
      };

      const handleStart = (e, isTouch = false) => {
        if (readOnly) return;
        const target = e.target;
        const { clientX, clientY } = getClientCoords(e);
        
        // Check what we're interacting with first
        const isResizeHandle = target.classList.contains('resize-handle') || target.closest('.resize-handle');
        const isRotateHandle = target.classList.contains('rotate-handle') || target.closest('.rotate-handle');
        const isHandle = isResizeHandle || isRotateHandle;
        
        // Prevent default for all touch interactions
        if (isTouch) {
          e.preventDefault();
          e.stopPropagation();
        } else if (isHandle) {
          e.preventDefault();
        }
        
        if (isResizeHandle) {
          setIsResizing(true);
          const rect = elementRef.current.getBoundingClientRect();
          resizeStartRef.current = { x: clientX, y: clientY, width: rect.width, height: rect.height };
          return;
        }
        if (isRotateHandle) {
          setIsRotating(true);
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          rotateStartRef.current = { x: clientX, y: clientY, angle: rotation, centerX, centerY };
          return;
        }
        setIsDragging(true);
        const rect = elementRef.current.getBoundingClientRect();
        dragOffsetRef.current = { x: clientX - rect.left, y: clientY - rect.top };
      };

      const handleMouseDown = (e) => handleStart(e, false);
      const handleTouchStart = (e) => {
        // Prevent default immediately for touch to avoid scrolling
        e.preventDefault();
        e.stopPropagation();
        handleStart(e, true);
      };

      const handleMove = useCallback((e) => {
        const { clientX, clientY } = getClientCoords(e);
        
        if (isRotating) {
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const startDx = rotateStartRef.current.x - rotateStartRef.current.centerX;
          const startDy = rotateStartRef.current.y - rotateStartRef.current.centerY;
          const currentDx = clientX - centerX;
          const currentDy = clientY - centerY;
          const startAngle = Math.atan2(startDy, startDx) * (180 / Math.PI);
          const currentAngle = Math.atan2(currentDy, currentDx) * (180 / Math.PI);
          let deltaAngle = currentAngle - startAngle;
          if (deltaAngle > 180) deltaAngle -= 360;
          else if (deltaAngle < -180) deltaAngle += 360;
          const rotationSensitivity = 0.15;
          deltaAngle *= rotationSensitivity;
          let newRotation = rotateStartRef.current.angle + deltaAngle;
          newRotation = ((newRotation % 360) + 360) % 360;
          setRotation(newRotation);
        } else if (isResizing) {
          const deltaX = clientX - resizeStartRef.current.x;
          const deltaY = clientY - resizeStartRef.current.y;
          let newWidth = Math.max(150, resizeStartRef.current.width + deltaX);
          let newHeight = Math.max(150, resizeStartRef.current.height + deltaY);
          newWidth = Math.min(newWidth, 500);
          newHeight = Math.min(newHeight, 500);
          setSize({ width: newWidth, height: newHeight });
        } else if (isDragging) {
          const parent = elementRef.current.parentElement;
          const parentRect = parent.getBoundingClientRect();
          let newX = clientX - parentRect.left - dragOffsetRef.current.x;
          let newY = clientY - parentRect.top - dragOffsetRef.current.y;
          setPosition({ x: newX, y: newY });
        }
      }, [isDragging, isResizing, isRotating, rotation]);

      const handleEnd = useCallback(() => {
        if (isDragging) {
          setIsDragging(false);
          onTransform({ x: position.x, y: position.y });
        }
        if (isResizing) {
          setIsResizing(false);
          onTransform({ width: size.width, height: size.height });
        }
        if (isRotating) {
          setIsRotating(false);
          onTransform({ rotation });
        }
      }, [isDragging, isResizing, isRotating, position, size, rotation, onTransform]);

      useEffect(() => {
        if (isDragging || isResizing || isRotating) {
          const handleMouseMove = (e) => handleMove(e);
          const handleTouchMove = (e) => { e.preventDefault(); handleMove(e); };
          
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mouseup', handleEnd);
          window.addEventListener('touchmove', handleTouchMove, { passive: false });
          window.addEventListener('touchend', handleEnd);
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleEnd);
            window.removeEventListener('touchmove', handleTouchMove);
            window.removeEventListener('touchend', handleEnd);
          };
        }
      }, [isDragging, isResizing, isRotating, handleMove, handleEnd]);

      return (
        <div
          ref={elementRef}
          className={`card-image-frame-draggable ${isDragging ? 'dragging' : ''} ${isResizing ? 'resizing' : ''} ${isRotating ? 'rotating' : ''}`}
          style={{
            position: 'absolute',
            left: position.x,
            top: position.y,
            width: size.width,
            height: size.height,
            transform: `rotate(${rotation}deg)`,
            backgroundImage: `url(${image})`,
            backgroundSize: 'contain',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat',
            zIndex: 3, /* Layer 3: Image_bg (above background) */
            touchAction: 'none',
          }}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
        >
          {!readOnly && (
            <>
              <div className="resize-handle"></div>
              <div className="rotate-handle" style={{ transform: `rotate(${-rotation}deg)` }}></div>
            </>
          )}
        </div>
      );
    }

    // ========== DRAGGABLE STICKER ==========
    function DraggableSticker({ sticker, onMove, onResize, onRotate, onDelete, readOnly }) {
      const [isDragging, setIsDragging] = useState(false);
      const [isResizing, setIsResizing] = useState(false);
      const [isRotating, setIsRotating] = useState(false);
      const [position, setPosition] = useState({ x: sticker.x || 0, y: sticker.y || 0 });
      const [size, setSize] = useState({ 
        width: sticker.width || 60, 
        height: sticker.height || 60 
      });
      const [rotation, setRotation] = useState(sticker.rotation || 0);
      const elementRef = useRef(null);
      const dragOffsetRef = useRef({ x: 0, y: 0 });
      const resizeStartRef = useRef({ x: 0, y: 0, width: 0, height: 0 });
      const rotateStartRef = useRef({ x: 0, y: 0, angle: 0, centerX: 0, centerY: 0 });

      // Get clientX/Y from mouse or touch event
      const getClientCoords = (e) => {
        if (e.touches && e.touches.length > 0) {
          return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
        }
        return { clientX: e.clientX, clientY: e.clientY };
      };

      const handleStart = (e, isTouch = false) => {
        if (readOnly) return;
        const target = e.target;
        if (target.classList.contains('delete-x')) return;
        const { clientX, clientY } = getClientCoords(e);
        
        if (target.classList.contains('resize-handle') || target.closest('.resize-handle')) {
          if (!isTouch) e.preventDefault();
          setIsResizing(true);
          const rect = elementRef.current.getBoundingClientRect();
          resizeStartRef.current = {
            x: clientX,
            y: clientY,
            width: rect.width,
            height: rect.height,
            startX: rect.left,
            startY: rect.top
          };
          return;
        }
        if (target.classList.contains('rotate-handle') || target.closest('.rotate-handle')) {
          if (!isTouch) e.preventDefault();
          setIsRotating(true);
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          rotateStartRef.current = {
            x: clientX,
            y: clientY,
            angle: rotation,
            centerX: centerX,
            centerY: centerY
          };
          return;
        }
        if (!isTouch) e.preventDefault();
        setIsDragging(true);
        const rect = elementRef.current.getBoundingClientRect();
        dragOffsetRef.current = { 
          x: clientX - rect.left, 
          y: clientY - rect.top 
        };
      };

      const handleMouseDown = (e) => handleStart(e, false);
      const handleTouchStart = (e) => handleStart(e, true);

      const handleMove = useCallback((e) => {
        const { clientX, clientY } = getClientCoords(e);
        
        if (isRotating) {
          const rect = elementRef.current.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const startDx = rotateStartRef.current.x - rotateStartRef.current.centerX;
          const startDy = rotateStartRef.current.y - rotateStartRef.current.centerY;
          const currentDx = clientX - centerX;
          const currentDy = clientY - centerY;
          
          const startAngle = Math.atan2(startDy, startDx) * (180 / Math.PI);
          const currentAngle = Math.atan2(currentDy, currentDx) * (180 / Math.PI);
          let deltaAngle = currentAngle - startAngle;
          
          if (deltaAngle > 180) {
            deltaAngle -= 360;
          } else if (deltaAngle < -180) {
            deltaAngle += 360;
          }
          
          const rotationSensitivity = 0.15;
          deltaAngle *= rotationSensitivity;
          
          let newRotation = rotateStartRef.current.angle + deltaAngle;
          newRotation = ((newRotation % 360) + 360) % 360;
          
          setRotation(newRotation);
        } else if (isResizing) {
          const parent = elementRef.current.parentElement;
          const parentRect = parent.getBoundingClientRect();
          const deltaX = clientX - resizeStartRef.current.x;
          const deltaY = clientY - resizeStartRef.current.y;
          
          let newWidth = resizeStartRef.current.width + deltaX;
          let newHeight = resizeStartRef.current.height + deltaY;
          
          newWidth = Math.max(30, newWidth);
          newHeight = Math.max(30, newHeight);
          
          const maxWidth = parentRect.width * 0.8;
          const maxHeight = parentRect.height * 0.8;
          newWidth = Math.min(newWidth, maxWidth);
          newHeight = Math.min(newHeight, maxHeight);
          
          setSize({ width: newWidth, height: newHeight });
        } else if (isDragging) {
          const parent = elementRef.current.parentElement;
          const parentRect = parent.getBoundingClientRect();
          let newX = clientX - parentRect.left - dragOffsetRef.current.x;
          let newY = clientY - parentRect.top - dragOffsetRef.current.y;
          
          setPosition({ x: newX, y: newY });
        }
      }, [isDragging, isResizing, isRotating, size.width, size.height]);

      const handleEnd = useCallback(() => {
        if (isDragging) {
          setIsDragging(false);
          onMove(position.x, position.y);
        }
        if (isResizing) {
          setIsResizing(false);
          onResize(size.width, size.height);
        }
        if (isRotating) {
          setIsRotating(false);
          onRotate(rotation);
        }
      }, [isDragging, isResizing, isRotating, position, size, rotation, onMove, onResize, onRotate]);

      useEffect(() => {
        if (isDragging || isResizing || isRotating) {
          const handleMouseMove = (e) => handleMove(e);
          const handleTouchMove = (e) => { e.preventDefault(); handleMove(e); };
          
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mouseup', handleEnd);
          window.addEventListener('touchmove', handleTouchMove, { passive: false });
          window.addEventListener('touchend', handleEnd);
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleEnd);
            window.removeEventListener('touchmove', handleTouchMove);
            window.removeEventListener('touchend', handleEnd);
          };
        }
      }, [isDragging, isResizing, isRotating, handleMove, handleEnd]);

      return (
        <div
          ref={elementRef}
          className={`card-sticker ${isDragging ? 'dragging' : ''} ${isResizing ? 'resizing' : ''} ${isRotating ? 'rotating' : ''}`}
          style={{ 
            left: position.x, 
            top: position.y,
            width: size.width,
            height: size.height,
            transform: `rotate(${rotation}deg)`,
            transformOrigin: 'center center',
            touchAction: 'none'
          }}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
        >
          {sticker.image ? (
            <img src={sticker.image} alt="Sticker" draggable={false} />
          ) : sticker.emoji ? (
            <span style={{ fontSize: size.width * 0.8 }}>{sticker.emoji}</span>
          ) : null}
          {!readOnly && (
            <>
              <span className="delete-x" onClick={onDelete}>✕</span>
              <div className="resize-handle"></div>
              <div 
                className="rotate-handle"
                style={{ transform: `translateX(-50%) rotate(${-rotation}deg)` }}
              ></div>
            </>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
